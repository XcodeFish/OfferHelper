# 桌面端功能架构设计

## 1. 整体架构概览

### 1.1 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    桌面端应用架构                              │
├─────────────────────────────────────────────────────────────┤
│  UI Layer (React + Electron Renderer)                      │
│  ├── 悬浮助手界面                                             │
│  ├── 设置面板                                               │
│  ├── 知识库界面                                             │
│  └── 状态指示器                                             │
├─────────────────────────────────────────────────────────────┤
│  Business Logic Layer                                      │
│  ├── 语音识别服务                                           │
│  ├── AI 分析引擎                                           │
│  ├── 知识库管理                                             │
│  ├── 面试助手核心                                           │
│  └── 用户数据管理                                           │
├─────────────────────────────────────────────────────────────┤
│  System Integration Layer                                  │
│  ├── 窗口管理器                                             │
│  ├── 隐私保护模块                                           │
│  ├── 快捷键管理                                             │
│  ├── 系统托盘                                               │
│  └── 文件系统接口                                           │
├─────────────────────────────────────────────────────────────┤
│  Data Layer                                                │
│  ├── 本地数据库 (SQLite)                                    │
│  ├── 缓存管理                                               │
│  ├── 配置存储                                               │
│  └── 日志系统                                               │
├─────────────────────────────────────────────────────────────┤
│  External Services                                         │
│  ├── AI API 服务                                           │
│  ├── 云端同步                                               │
│  ├── 更新服务                                               │
│  └── 统计分析                                               │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选择

- **主框架**: Electron 25+
- **UI 框架**: React 18 + TypeScript
- **状态管理**: Zustand
- **样式方案**: Tailwind CSS + Framer Motion
- **数据库**: SQLite + Prisma ORM
- **语音识别**: Web Speech API + 百度语音 API
- **AI 服务**: OpenAI API + 本地模型
- **构建工具**: Vite + Electron Builder

## 2. 核心模块设计

### 2.1 窗口管理器 (WindowManager)

```typescript
interface WindowConfig {
  width: number;
  height: number;
  x?: number;
  y?: number;
  alwaysOnTop: boolean;
  skipTaskbar: boolean;
  transparent: boolean;
  frame: boolean;
}

class WindowManager {
  private mainWindow: BrowserWindow | null = null;
  private settingsWindow: BrowserWindow | null = null;
  private isHidden: boolean = false;

  constructor() {
    this.initializeMainWindow();
    this.setupEventHandlers();
  }

  private initializeMainWindow(): void {
    const config: WindowConfig = {
      width: 400,
      height: 600,
      alwaysOnTop: true,
      skipTaskbar: true,
      transparent: true,
      frame: false
    };

    this.mainWindow = new BrowserWindow({
      ...config,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        webSecurity: false
      }
    });

    // 设置内容保护
    this.mainWindow.setContentProtection(true);

    // 加载应用
    this.mainWindow.loadFile('dist/index.html');
  }

  public toggleVisibility(): void {
    if (!this.mainWindow) return;

    if (this.isHidden) {
      this.show();
    } else {
      this.hide();
    }
  }

  public hide(): void {
    if (this.mainWindow && this.mainWindow.isVisible()) {
      this.mainWindow.hide();
      this.isHidden = true;
      this.notifyStatusChange('hidden');
    }
  }

  public show(): void {
    if (this.mainWindow && !this.mainWindow.isVisible()) {
      this.mainWindow.show();
      this.isHidden = false;
      this.notifyStatusChange('visible');
    }
  }

  private setupEventHandlers(): void {
    // 窗口事件处理
    this.mainWindow?.on('closed', () => {
      this.mainWindow = null;
    });

    // 全局快捷键
    globalShortcut.register('CommandOrControl+Shift+H', () => {
      this.toggleVisibility();
    });
  }

  private notifyStatusChange(status: 'hidden' | 'visible'): void {
    // 通知其他模块窗口状态变化
    EventBus.emit('window-status-changed', status);
  }
}
```

### 2.2 隐私保护模块 (PrivacyProtector)

```typescript
interface ScreenSharingApp {
  name: string;
  processName: string;
  windowTitle?: string;
}

class PrivacyProtector {
  private isMonitoring: boolean = false;
  private checkInterval: NodeJS.Timeout | null = null;
  private windowManager: WindowManager;

  private readonly SCREEN_SHARING_APPS: ScreenSharingApp[] = [
    { name: 'Zoom', processName: 'zoom.exe' },
    { name: 'Microsoft Teams', processName: 'Teams.exe' },
    { name: 'Skype', processName: 'Skype.exe' },
    { name: 'Google Chrome', processName: 'chrome.exe' },
    { name: 'Tencent Meeting', processName: 'wemeet.exe' },
    { name: 'DingTalk', processName: 'DingTalk.exe' }
  ];

  constructor(windowManager: WindowManager) {
    this.windowManager = windowManager;
  }

  public startMonitoring(): void {
    if (this.isMonitoring) return;

    this.isMonitoring = true;
    this.checkInterval = setInterval(async () => {
      await this.checkScreenSharing();
    }, 1000);

    console.log('隐私保护监控已启动');
  }

  public stopMonitoring(): void {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    this.isMonitoring = false;
    console.log('隐私保护监控已停止');
  }

  private async checkScreenSharing(): Promise<void> {
    try {
      const isSharing = await this.detectScreenSharing();

      if (isSharing) {
        this.windowManager.hide();
        this.showTrayNotification('检测到屏幕共享，助手已自动隐藏');
      }
    } catch (error) {
      console.error('屏幕共享检测失败:', error);
    }
  }

  private async detectScreenSharing(): Promise<boolean> {
    // 方法1: 检测进程
    const processDetection = await this.checkProcesses();

    // 方法2: 检测窗口标题
    const windowDetection = await this.checkWindowTitles();

    // 方法3: 检测系统API调用
    const apiDetection = await this.checkSystemAPIs();

    return processDetection || windowDetection || apiDetection;
  }

  private async checkProcesses(): Promise<boolean> {
    const { exec } = require('child_process');
    const util = require('util');
    const execAsync = util.promisify(exec);

    try {
      let command: string;

      if (process.platform === 'win32') {
        command = 'tasklist /fo csv | findstr /i "zoom\\|teams\\|skype\\|chrome\\|wemeet\\|dingtalk"';
      } else if (process.platform === 'darwin') {
        command = 'ps aux | grep -i "zoom\\|teams\\|skype\\|chrome\\|wemeet\\|dingtalk"';
      } else {
        command = 'ps aux | grep -i "zoom\\|teams\\|skype\\|chrome\\|wemeet\\|dingtalk"';
      }

      const { stdout } = await execAsync(command);
      return stdout.trim().length > 0;
    } catch (error) {
      return false;
    }
  }

  private async checkWindowTitles(): Promise<boolean> {
    // 使用 Electron 的 screen API 检测活动窗口
    const { screen } = require('electron');

    try {
      const sources = await desktopCapturer.getSources({
        types: ['window'],
        thumbnailSize: { width: 1, height: 1 }
      });

      const sharingKeywords = [
        '正在共享屏幕', '屏幕共享', 'Screen Sharing',
        'Zoom Meeting', 'Teams Meeting', 'Skype Call'
      ];

      return sources.some(source =>
        sharingKeywords.some(keyword =>
          source.name.toLowerCase().includes(keyword.toLowerCase())
        )
      );
    } catch (error) {
      return false;
    }
  }

  private async checkSystemAPIs(): Promise<boolean> {
    // 检测系统级屏幕捕获API调用
    if (process.platform === 'win32') {
      return this.checkWindowsScreenCapture();
    } else if (process.platform === 'darwin') {
      return this.checkMacOSScreenCapture();
    }
    return false;
  }

  private checkWindowsScreenCapture(): boolean {
    // 使用 Windows API 检测屏幕捕获
    try {
      const ffi = require('ffi-napi');
      const user32 = ffi.Library('user32', {
        'GetSystemMetrics': ['int', ['int']]
      });

      // 检测是否有应用正在捕获屏幕
      const captureFlag = user32.GetSystemMetrics(0x1000); // SM_REMOTESESSION
      return captureFlag > 0;
    } catch (error) {
      return false;
    }
  }

  private checkMacOSScreenCapture(): boolean {
    // 使用 macOS API 检测屏幕捕获
    try {
      const { execSync } = require('child_process');
      const result = execSync('system_profiler SPDisplaysDataType | grep -i "resolution"');
      // 简化的检测逻辑，实际应该更复杂
      return result.toString().includes('capture');
    } catch (error) {
      return false;
    }
  }

  private showTrayNotification(message: string): void {
    const { Notification } = require('electron');

    if (Notification.isSupported()) {
      new Notification({
        title: 'OfferHelper',
        body: message,
        icon: path.join(__dirname, 'assets/icon.png')
      }).show();
    }
  }
}
```

### 2.3 语音识别服务 (SpeechRecognitionService)

```typescript
interface SpeechConfig {
  language: string;
  continuous: boolean;
  interimResults: boolean;
  maxAlternatives: number;
}

class SpeechRecognitionService {
  private recognition: SpeechRecognition | null = null;
  private isListening: boolean = false;
  private config: SpeechConfig;

  constructor() {
    this.config = {
      language: 'zh-CN',
      continuous: true,
      interimResults: true,
      maxAlternatives: 3
    };
    this.initializeRecognition();
  }

  private initializeRecognition(): void {
    if ('webkitSpeechRecognition' in window) {
      this.recognition = new webkitSpeechRecognition();
    } else if ('SpeechRecognition' in window) {
      this.recognition = new SpeechRecognition();
    } else {
      console.error('浏览器不支持语音识别');
      return;
    }

    this.setupRecognitionConfig();
    this.setupEventHandlers();
  }

  private setupRecognitionConfig(): void {
    if (!this.recognition) return;

    this.recognition.lang = this.config.language;
    this.recognition.continuous = this.config.continuous;
    this.recognition.interimResults = this.config.interimResults;
    this.recognition.maxAlternatives = this.config.maxAlternatives;
  }

  private setupEventHandlers(): void {
    if (!this.recognition) return;

    this.recognition.onstart = () => {
      this.isListening = true;
      EventBus.emit('speech-recognition-started');
    };

    this.recognition.onresult = (event) => {
      const results = Array.from(event.results);
      const transcript = results
        .map(result => result[0].transcript)
        .join('');

      if (event.results[event.results.length - 1].isFinal) {
        this.handleFinalResult(transcript);
      } else {
        this.handleInterimResult(transcript);
      }
    };

    this.recognition.onerror = (event) => {
      console.error('语音识别错误:', event.error);
      EventBus.emit('speech-recognition-error', event.error);
    };

    this.recognition.onend = () => {
      this.isListening = false;
      EventBus.emit('speech-recognition-ended');
    };
  }

  public startListening(): void {
    if (this.recognition && !this.isListening) {
      this.recognition.start();
    }
  }

  public stopListening(): void {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
    }
  }

  private handleFinalResult(transcript: string): void {
    // 发送到 AI 分析引擎
    EventBus.emit('speech-final-result', transcript);
  }

  private handleInterimResult(transcript: string): void {
    // 实时显示识别结果
    EventBus.emit('speech-interim-result', transcript);
  }
}
```

### 2.4 AI 分析引擎 (AIAnalysisEngine)

```typescript
interface AIResponse {
  answer: string;
  confidence: number;
  keywords: string[];
  category: string;
  suggestions: string[];
}

class AIAnalysisEngine {
  private apiKey: string;
  private baseURL: string;
  private localModel: any = null;

  constructor() {
    this.apiKey = process.env.OPENAI_API_KEY || '';
    this.baseURL = 'https://api.openai.com/v1';
    this.initializeLocalModel();
  }

  private async initializeLocalModel(): Promise<void> {
    try {
      // 初始化本地模型（如果可用）
      const { pipeline } = await import('@xenova/transformers');
      this.localModel = await pipeline('text-generation', 'Xenova/gpt2');
    } catch (error) {
      console.log('本地模型初始化失败，将使用云端API');
    }
  }

  public async analyzeQuestion(question: string): Promise<AIResponse> {
    try {
      // 优先使用云端 API
      if (this.apiKey) {
        return await this.analyzeWithCloudAPI(question);
      }

      // 备用本地模型
      if (this.localModel) {
        return await this.analyzeWithLocalModel(question);
      }

      throw new Error('没有可用的AI服务');
    } catch (error) {
      console.error('AI分析失败:', error);
      return this.getFallbackResponse(question);
    }
  }

  private async analyzeWithCloudAPI(question: string): Promise<AIResponse> {
    const response = await fetch(`${this.baseURL}/chat/completions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: '你是一个专业的面试助手，请为以下面试问题提供简洁、专业的回答建议。'
          },
          {
            role: 'user',
            content: question
          }
        ],
        max_tokens: 500,
        temperature: 0.7
      })
    });

    const data = await response.json();
    const answer = data.choices[0].message.content;

    return {
      answer,
      confidence: 0.9,
      keywords: this.extractKeywords(question),
      category: this.categorizeQuestion(question),
      suggestions: this.generateSuggestions(answer)
    };
  }

  private async analyzeWithLocalModel(question: string): Promise<AIResponse> {
    const result = await this.localModel(question, {
      max_length: 200,
      num_return_sequences: 1
    });

    return {
      answer: result[0].generated_text,
      confidence: 0.7,
      keywords: this.extractKeywords(question),
      category: this.categorizeQuestion(question),
      suggestions: []
    };
  }

  private getFallbackResponse(question: string): AIResponse {
    const knowledgeBase = this.getKnowledgeBase();
    const matchedAnswer = knowledgeBase.find(item =>
      question.toLowerCase().includes(item.keyword.toLowerCase())
    );

    return {
      answer: matchedAnswer?.answer || '抱歉，暂时无法分析此问题。',
      confidence: 0.5,
      keywords: this.extractKeywords(question),
      category: 'unknown',
      suggestions: []
    };
  }

  private extractKeywords(text: string): string[] {
    // 简单的关键词提取逻辑
    const keywords = text
      .toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 2)
      .slice(0, 5);

    return keywords;
  }

  private categorizeQuestion(question: string): string {
    const categories = {
      'technical': ['算法', '数据结构', '编程', '代码', '技术'],
      'behavioral': ['经验', '团队', '项目', '挑战', '解决'],
      'system': ['系统', '架构', '设计', '扩展', '性能'],
      'frontend': ['前端', 'React', 'Vue', 'JavaScript', 'CSS'],
      'backend': ['后端', 'Node.js', 'Python', 'Java', '数据库']
    };

    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some(keyword => question.includes(keyword))) {
        return category;
      }
    }

    return 'general';
  }

  private generateSuggestions(answer: string): string[] {
    return [
      '可以结合具体项目经验来回答',
      '注意突出你的技术能力',
      '保持回答简洁明了'
    ];
  }

  private getKnowledgeBase(): Array<{keyword: string, answer: string}> {
    return [
      {
        keyword: 'JavaScript',
        answer: 'JavaScript是一种动态类型的编程语言，主要用于Web开发...'
      },
      {
        keyword: 'React',
        answer: 'React是Facebook开发的用于构建用户界面的JavaScript库...'
      }
      // 更多知识库条目
    ];
  }
}
```

### 2.5 知识库管理 (KnowledgeBaseManager)

```typescript
interface KnowledgeItem {
  id: string;
  title: string;
  content: string;
  category: string;
  tags: string[];
  difficulty: 'easy' | 'medium' | 'hard';
  frequency: number;
  lastUpdated: Date;
}

class KnowledgeBaseManager {
  private db: Database;
  private searchIndex: any;

  constructor() {
    this.initializeDatabase();
    this.initializeSearchIndex();
  }

  private async initializeDatabase(): Promise<void> {
    const Database = require('better-sqlite3');
    this.db = new Database('knowledge.db');

    // 创建表结构
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS knowledge_items (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        category TEXT NOT NULL,
        tags TEXT NOT NULL,
        difficulty TEXT NOT NULL,
        frequency INTEGER DEFAULT 0,
        last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
  }

  private initializeSearchIndex(): void {
    // 使用 Fuse.js 进行模糊搜索
    const Fuse = require('fuse.js');
    const options = {
      keys: ['title', 'content', 'tags'],
      threshold: 0.3,
      includeScore: true
    };

    const items = this.getAllItems();
    this.searchIndex = new Fuse(items, options);
  }

  public async addItem(item: Omit<KnowledgeItem, 'id' | 'lastUpdated'>): Promise<string> {
    const id = this.generateId();
    const stmt = this.db.prepare(`
      INSERT INTO knowledge_items (id, title, content, category, tags, difficulty, frequency)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      id,
      item.title,
      item.content,
      item.category,
      JSON.stringify(item.tags),
      item.difficulty,
      item.frequency
    );

    this.updateSearchIndex();
    return id;
  }

  public searchItems(query: string, limit: number = 10): KnowledgeItem[] {
    const results = this.searchIndex.search(query);
    return results
      .slice(0, limit)
      .map((result: any) => result.item);
  }

  public getItemsByCategory(category: string): KnowledgeItem[] {
    const stmt = this.db.prepare('SELECT * FROM knowledge_items WHERE category = ?');
    const rows = stmt.all(category);
    return rows.map(this.mapRowToItem);
  }

  public getFrequentItems(limit: number = 20): KnowledgeItem[] {
    const stmt = this.db.prepare(`
      SELECT * FROM knowledge_items
      ORDER BY frequency DESC
      LIMIT ?
    `);
    const rows = stmt.all(limit);
    return rows.map(this.mapRowToItem);
  }

  public incrementFrequency(id: string): void {
    const stmt = this.db.prepare(`
      UPDATE knowledge_items
      SET frequency = frequency + 1
      WHERE id = ?
    `);
    stmt.run(id);
  }

  private getAllItems(): KnowledgeItem[] {
    const stmt = this.db.prepare('SELECT * FROM knowledge_items');
    const rows = stmt.all();
    return rows.map(this.mapRowToItem);
  }

  private mapRowToItem(row: any): KnowledgeItem {
    return {
      id: row.id,
      title: row.title,
      content: row.content,
      category: row.category,
      tags: JSON.parse(row.tags),
      difficulty: row.difficulty,
      frequency: row.frequency,
      lastUpdated: new Date(row.last_updated)
    };
  }

  private updateSearchIndex(): void {
    const items = this.getAllItems();
    this.searchIndex.setCollection(items);
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}
```

## 3. 用户界面设计

### 3.1 主界面组件

```tsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

interface MainAppProps {
  windowManager: WindowManager;
  speechService: SpeechRecognitionService;
  aiEngine: AIAnalysisEngine;
}

const MainApp: React.FC<MainAppProps> = ({
  windowManager,
  speechService,
  aiEngine
}) => {
  const [isListening, setIsListening] = useState(false);
  const [currentQuestion, setCurrentQuestion] = useState('');
  const [aiResponse, setAiResponse] = useState<AIResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    // 监听语音识别事件
    EventBus.on('speech-final-result', handleSpeechResult);
    EventBus.on('speech-recognition-started', () => setIsListening(true));
    EventBus.on('speech-recognition-ended', () => setIsListening(false));

    return () => {
      EventBus.off('speech-final-result', handleSpeechResult);
      EventBus.off('speech-recognition-started');
      EventBus.off('speech-recognition-ended');
    };
  }, []);

  const handleSpeechResult = async (transcript: string) => {
    setCurrentQuestion(transcript);
    setIsLoading(true);

    try {
      const response = await aiEngine.analyzeQuestion(transcript);
      setAiResponse(response);
    } catch (error) {
      console.error('AI分析失败:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const toggleListening = () => {
    if (isListening) {
      speechService.stopListening();
    } else {
      speechService.startListening();
    }
  };

  return (
    <div className="app-container">
      <DragArea />

      <div className="content-area">
        <StatusBar
          isListening={isListening}
          isLoading={isLoading}
        />

        <QuestionDisplay
          question={currentQuestion}
          isListening={isListening}
        />

        <AnimatePresence>
          {aiResponse && (
            <AnswerPanel
              response={aiResponse}
              onClose={() => setAiResponse(null)}
            />
          )}
        </AnimatePresence>

        <ControlPanel
          isListening={isListening}
          onToggleListening={toggleListening}
          onHide={() => windowManager.hide()}
        />
      </div>
    </div>
  );
};

const DragArea: React.FC = () => (
  <div className="drag-area">
    <div className="app-title">OfferHelper</div>
    <div className="window-controls">
      <button className="control-btn minimize">−</button>
      <button className="control-btn close">×</button>
    </div>
  </div>
);

const StatusBar: React.FC<{
  isListening: boolean;
  isLoading: boolean;
}> = ({ isListening, isLoading }) => (
  <div className="status-bar">
    <div className={`status-indicator ${isListening ? 'listening' : 'idle'}`}>
      {isListening && <div className="pulse-animation" />}
    </div>
    <span className="status-text">
      {isLoading ? '分析中...' : isListening ? '正在监听...' : '待机中'}
    </span>
  </div>
);

const QuestionDisplay: React.FC<{
  question: string;
  isListening: boolean;
}> = ({ question, isListening }) => (
  <motion.div
    className="question-display"
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.3 }}
  >
    <h3>面试官问题</h3>
    <div className="question-text">
      {question || (isListening ? '正在监听面试官提问...' : '点击开始监听')}
    </div>
  </motion.div>
);

const AnswerPanel: React.FC<{
  response: AIResponse;
  onClose: () => void;
}> = ({ response, onClose }) => (
  <motion.div
    className="answer-panel"
    initial={{ opacity: 0, scale: 0.9 }}
    animate={{ opacity: 1, scale: 1 }}
    exit={{ opacity: 0, scale: 0.9 }}
    transition={{ duration: 0.2 }}
  >
    <div className="answer-header">
      <h3>建议回答</h3>
      <button onClick={onClose} className="close-btn">×</button>
    </div>

    <div className="answer-content">
      <div className="confidence-bar">
        <span>置信度: {Math.round(response.confidence * 100)}%</span>
        <div className="progress-bar">
          <div
            className="progress-fill"
            style={{ width: `${response.confidence * 100}%` }}
          />
        </div>
      </div>

      <div className="answer-text">
        {response.answer}
      </div>

      {response.keywords.length > 0 && (
        <div className="keywords">
          <span>关键词: </span>
          {response.keywords.map(keyword => (
            <span key={keyword} className="keyword-tag">
              {keyword}
            </span>
          ))}
        </div>
      )}

      {response.suggestions.length > 0 && (
        <div className="suggestions">
          <h4>回答建议</h4>
          <ul>
            {response.suggestions.map((suggestion, index) => (
              <li key={index}>{suggestion}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  </motion.div>
);

const ControlPanel: React.FC<{
  isListening: boolean;
  onToggleListening: () => void;
  onHide: () => void;
}> = ({ isListening, onToggleListening, onHide }) => (
  <div className="control-panel">
    <button
      className={`control-btn primary ${isListening ? 'listening' : ''}`}
      onClick={onToggleListening}
    >
      {isListening ? '停止监听' : '开始监听'}
    </button>

    <button className="control-btn secondary" onClick={onHide}>
      隐藏助手
    </button>
  </div>
);

export default MainApp;
```

### 3.2 样式定义

```css
/* 主应用样式 */
.app-container {
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  border-radius: 12px;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.drag-area {
  -webkit-app-region: drag;
  height: 40px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  color: white;
}

.app-title {
  font-size: 14px;
  font-weight: 600;
}

.window-controls {
  -webkit-app-region: no-drag;
  display: flex;
  gap: 8px;
}

.control-btn {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: all 0.2s ease;
}

.control-btn.minimize {
  background: #ffbd2e;
}

.control-btn.close {
  background: #ff5f57;
  color: white;
}

.content-area {
  padding: 20px;
  height: calc(100% - 40px);
  overflow-y: auto;
}

.status-bar {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
  padding: 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.status-indicator {
  position: relative;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #6b7280;
  transition: all 0.3s ease;
}

.status-indicator.listening {
  background: #10b981;
}

.pulse-animation {
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border-radius: 50%;
  background: rgba(16, 185, 129, 0.3);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  100% {
    transform: scale(1.5);
    opacity: 0;
  }
}

.status-text {
  color: #d1d5db;
  font-size: 14px;
}

.question-display {
  margin-bottom: 20px;
  padding: 16px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  border-left: 4px solid #667eea;
}

.question-display h3 {
  margin: 0 0 12px 0;
  color: #f3f4f6;
  font-size: 16px;
  font-weight: 600;
}

.question-text {
  color: #d1d5db;
  font-size: 14px;
  line-height: 1.5;
  min-height: 40px;
}

.answer-panel {
  background: rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.answer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.answer-header h3 {
  margin: 0;
  color: #f3f4f6;
  font-size: 16px;
  font-weight: 600;
}

.close-btn {
  background: none;
  border: none;
  color: #9ca3af;
  font-size: 20px;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.close-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #f3f4f6;
}

.confidence-bar {
  margin-bottom: 16px;
}

.confidence-bar span {
  color: #d1d5db;
  font-size: 12px;
  margin-bottom: 8px;
  display: block;
}

.progress-bar {
  width: 100%;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #10b981, #059669);
  transition: width 0.3s ease;
}

.answer-text {
  color: #f3f4f6;
  font-size: 14px;
  line-height: 1.6;
  margin-bottom: 16px;
  padding: 12px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
}

.keywords {
  margin-bottom: 16px;
}

.keywords span {
  color: #d1d5db;
  font-size: 12px;
}

.keyword-tag {
  display: inline-block;
  background: rgba(102, 126, 234, 0.2);
  color: #a5b4fc;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 11px;
  margin: 0 4px 4px 0;
}

.suggestions {
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  padding-top: 16px;
}

.suggestions h4 {
  margin: 0 0 12px 0;
  color: #f3f4f6;
  font-size: 14px;
  font-weight: 600;
}

.suggestions ul {
  margin: 0;
  padding-left: 16px;
  color: #d1d5db;
  font-size: 13px;
}

.suggestions li {
  margin-bottom: 8px;
  line-height: 1.4;
}

.control-panel {
  display: flex;
  gap: 12px;
  margin-top: auto;
}

.control-panel .control-btn {
  flex: 1;
  height: 44px;
  border-radius: 8px;
  border: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.control-panel .control-btn.primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.control-panel .control-btn.primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.control-panel .control-btn.primary.listening {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
}

.control-panel .control-btn.secondary {
  background: rgba(255, 255, 255, 0.1);
  color: #d1d5db;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.control-panel .control-btn.secondary:hover {
  background: rgba(255, 255, 255, 0.15);
  color: #f3f4f6;
}
```

## 4. 数据存储设计

### 4.1 本地数据库结构

```sql
-- 用户配置表
CREATE TABLE user_settings (
  id INTEGER PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  value TEXT NOT NULL,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 面试记录表
CREATE TABLE interview_sessions (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  company TEXT,
  position TEXT,
  start_time DATETIME NOT NULL,
  end_time DATETIME,
  status TEXT DEFAULT 'active',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 问答记录表
CREATE TABLE qa_records (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  question TEXT NOT NULL,
  answer TEXT,
  ai_response TEXT,
  confidence REAL,
  category TEXT,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (session_id) REFERENCES interview_sessions(id)
);

-- 知识库表
CREATE TABLE knowledge_items (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  category TEXT NOT NULL,
  tags TEXT NOT NULL,
  difficulty TEXT NOT NULL,
  frequency INTEGER DEFAULT 0,
  last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 使用统计表
CREATE TABLE usage_stats (
  id INTEGER PRIMARY KEY,
  date TEXT NOT NULL,
  sessions_count INTEGER DEFAULT 0,
  questions_count INTEGER DEFAULT 0,
  total_time INTEGER DEFAULT 0,
  UNIQUE(date)
);
```

### 4.2 配置管理

```typescript
interface AppConfig {
  appearance: {
    theme: 'dark' | 'light';
    opacity: number;
    alwaysOnTop: boolean;
    position: { x: number; y: number };
  };
  speech: {
    language: string;
    continuous: boolean;
    sensitivity: number;
  };
  ai: {
    provider: 'openai' | 'local';
    model: string;
    temperature: number;
    maxTokens: number;
  };
  privacy: {
    autoHide: boolean;
    hideOnScreenShare: boolean;
    emergencyHideKey: string;
  };
  shortcuts: {
    toggleVisibility: string;
    startListening: string;
    stopListening: string;
    emergencyHide: string;
  };
}

class ConfigManager {
  private configPath: string;
  private config: AppConfig;

  constructor() {
    this.configPath = path.join(app.getPath('userData'), 'config.json');
    this.loadConfig();
  }

  private loadConfig(): void {
    try {
      if (fs.existsSync(this.configPath)) {
        const data = fs.readFileSync(this.configPath, 'utf8');
        this.config = { ...this.getDefaultConfig(), ...JSON.parse(data) };
      } else {
        this.config = this.getDefaultConfig();
        this.saveConfig();
      }
    } catch (error) {
      console.error('配置加载失败:', error);
      this.config = this.getDefaultConfig();
    }
  }

  private getDefaultConfig(): AppConfig {
    return {
      appearance: {
        theme: 'dark',
        opacity: 0.9,
        alwaysOnTop: true,
        position: { x: 100, y: 100 }
      },
      speech: {
        language: 'zh-CN',
        continuous: true,
        sensitivity: 0.7
      },
      ai: {
        provider: 'openai',
        model: 'gpt-3.5-turbo',
        temperature: 0.7,
        maxTokens: 500
      },
      privacy: {
        autoHide: true,
        hideOnScreenShare: true,
        emergencyHideKey: 'CommandOrControl+Shift+H'
      },
      shortcuts: {
        toggleVisibility: 'CommandOrControl+Shift+H',
        startListening: 'CommandOrControl+Shift+L',
        stopListening: 'CommandOrControl+Shift+S',
        emergencyHide: 'CommandOrControl+CommandOrControl'
      }
    };
  }

  public getConfig(): AppConfig {
    return this.config;
  }

  public updateConfig(updates: Partial<AppConfig>): void {
    this.config = { ...this.config, ...updates };
    this.saveConfig();
  }

  private saveConfig(): void {
    try {
      fs.writeFileSync(this.configPath, JSON.stringify(this.config, null, 2));
    } catch (error) {
      console.error('配置保存失败:', error);
    }
  }
}
```

## 5. 事件系统设计

### 5.1 事件总线

```typescript
type EventCallback = (...args: any[]) => void;

class EventBus {
  private static instance: EventBus;
  private events: Map<string, EventCallback[]> = new Map();

  public static getInstance(): EventBus {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }

  public on(event: string, callback: EventCallback): void {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
  }

  public off(event: string, callback?: EventCallback): void {
    if (!this.events.has(event)) return;

    if (callback) {
      const callbacks = this.events.get(event)!;
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    } else {
      this.events.delete(event);
    }
  }

  public emit(event: string, ...args: any[]): void {
    if (!this.events.has(event)) return;

    const callbacks = this.events.get(event)!;
    callbacks.forEach(callback => {
      try {
        callback(...args);
      } catch (error) {
        console.error(`事件处理错误 [${event}]:`, error);
      }
    });
  }

  public once(event: string, callback: EventCallback): void {
    const onceCallback = (...args: any[]) => {
      callback(...args);
      this.off(event, onceCallback);
    };
    this.on(event, onceCallback);
  }
}

// 导出单例实例
export const EventBus = EventBus.getInstance();
```

### 5.2 事件定义

```typescript
// 事件类型定义
export interface AppEvents {
  // 窗口事件
  'window-status-changed': (status: 'hidden' | 'visible') => void;
  'window-position-changed': (position: { x: number; y: number }) => void;

  // 语音识别事件
  'speech-recognition-started': () => void;
  'speech-recognition-ended': () => void;
  'speech-recognition-error': (error: string) => void;
  'speech-final-result': (transcript: string) => void;
  'speech-interim-result': (transcript: string) => void;

  // AI 分析事件
  'ai-analysis-started': (question: string) => void;
  'ai-analysis-completed': (response: AIResponse) => void;
  'ai-analysis-failed': (error: string) => void;

  // 隐私保护事件
  'screen-sharing-detected': () => void;
  'screen-sharing-stopped': () => void;
  'privacy-mode-enabled': () => void;
  'privacy-mode-disabled': () => void;

  // 用户交互事件
  'user-action': (action: string, data?: any) => void;
  'settings-changed': (settings: Partial<AppConfig>) => void;
}
```

## 6. 性能优化策略

### 6.1 内存管理

```typescript
class MemoryManager {
  private memoryThreshold = 100 * 1024 * 1024; // 100MB
  private checkInterval = 30000; // 30秒
  private intervalId: NodeJS.Timeout | null = null;

  public startMonitoring(): void {
    this.intervalId = setInterval(() => {
      this.checkMemoryUsage();
    }, this.checkInterval);
  }

  public stopMonitoring(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  private checkMemoryUsage(): void {
    const memUsage = process.memoryUsage();

    if (memUsage.heapUsed > this.memoryThreshold) {
      this.optimizeMemory();
    }

    // 记录内存使用情况
    console.log('内存使用情况:', {
      heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024) + 'MB',
      heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024) + 'MB',
      external: Math.round(memUsage.external / 1024 / 1024) + 'MB'
    });
  }

  private optimizeMemory(): void {
    // 强制垃圾回收
    if (global.gc) {
      global.gc();
    }

    // 清理事件监听器
    this.cleanupEventListeners();

    // 清理缓存
    this.clearCache();

    console.log('内存优化完成');
  }

  private cleanupEventListeners(): void {
    // 清理未使用的事件监听器
    EventBus.emit('cleanup-listeners');
  }

  private clearCache(): void {
    // 清理应用缓存
    if (global.appCache) {
      global.appCache.clear();
    }
  }
}
```

### 6.2 渲染优化

```typescript
// 虚拟滚动组件
import React, { useState, useEffect, useMemo } from 'react';

interface VirtualScrollProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
}

function VirtualScroll<T>({
  items,
  itemHeight,
  containerHeight,
  renderItem
}: VirtualScrollProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);

  const visibleItems = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + 1,
      items.length
    );

    return items.slice(startIndex, endIndex).map((item, index) => ({
      item,
      index: startIndex + index
    }));
  }, [items, scrollTop, itemHeight, containerHeight]);

  const totalHeight = items.length * itemHeight;
  const offsetY = Math.floor(scrollTop / itemHeight) * itemHeight;

  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map(({ item, index }) => (
            <div key={index} style={{ height: itemHeight }}>
              {renderItem(item, index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// 防抖Hook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 节流Hook
function useThrottle<T>(value: T, limit: number): T {
  const [throttledValue, setThrottledValue] = useState<T>(value);
  const lastRan = useRef(Date.now());

  useEffect(() => {
    const handler = setTimeout(() => {
      if (Date.now() - lastRan.current >= limit) {
        setThrottledValue(value);
        lastRan.current = Date.now();
      }
    }, limit - (Date.now() - lastRan.current));

    return () => {
      clearTimeout(handler);
    };
  }, [value, limit]);

  return throttledValue;
}
```

## 7. 错误处理与日志

### 7.1 错误处理系统

```typescript
interface ErrorInfo {
  message: string;
  stack?: string;
  timestamp: Date;
  level: 'error' | 'warn' | 'info';
  context?: any;
}

class ErrorHandler {
  private logFile: string;

  constructor() {
    this.logFile = path.join(app.getPath('userData'), 'error.log');
    this.setupGlobalErrorHandlers();
  }

  private setupGlobalErrorHandlers(): void {
    // 处理未捕获的异常
    process.on('uncaughtException', (error) => {
      this.handleError(error, 'uncaughtException');
    });

    // 处理未处理的Promise拒绝
    process.on('unhandledRejection', (reason, promise) => {
      this.handleError(new Error(String(reason)), 'unhandledRejection', { promise });
    });

    // 处理渲染进程错误
    if (process.type === 'renderer') {
      window.addEventListener('error', (event) => {
        this.handleError(event.error, 'renderer-error', {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno
        });
      });
    }
  }

  public handleError(
    error: Error,
    type: string = 'general',
    context?: any
  ): void {
    const errorInfo: ErrorInfo = {
      message: error.message,
      stack: error.stack,
      timestamp: new Date(),
      level: 'error',
      context: { type, ...context }
    };

    // 记录到文件
    this.logToFile(errorInfo);

    // 发送到错误监控服务
    this.sendToMonitoring(errorInfo);

    // 通知用户（如果是严重错误）
    if (this.isCriticalError(error)) {
      this.notifyUser(errorInfo);
    }
  }

  private logToFile(errorInfo: ErrorInfo): void {
    const logEntry = JSON.stringify(errorInfo) + '\n';

    try {
      fs.appendFileSync(this.logFile, logEntry);
    } catch (writeError) {
      console.error('无法写入错误日志:', writeError);
    }
  }

  private sendToMonitoring(errorInfo: ErrorInfo): void {
    // 发送到错误监控服务（如 Sentry）
    if (process.env.NODE_ENV === 'production') {
      // Sentry.captureException(errorInfo);
    }
  }

  private isCriticalError(error: Error): boolean {
    const criticalKeywords = [
      'ENOENT',
      'EACCES',
      'Cannot read property',
      'is not a function'
    ];

    return criticalKeywords.some(keyword =>
      error.message.includes(keyword)
    );
  }

  private notifyUser(errorInfo: ErrorInfo): void {
    const { dialog } = require('electron');

    dialog.showErrorBox(
      '应用程序错误',
      `发生了一个错误，应用程序可能无法正常工作。\n\n错误信息: ${errorInfo.message}`
    );
  }
}
```

### 7.2 日志系统

```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

class Logger {
  private logLevel: LogLevel = LogLevel.INFO;
  private logFile: string;
  private maxLogSize = 10 * 1024 * 1024; // 10MB

  constructor() {
    this.logFile = path.join(app.getPath('userData'), 'app.log');
  }

  public debug(message: string, data?: any): void {
    this.log(LogLevel.DEBUG, message, data);
  }

  public info(message: string, data?: any): void {
    this.log(LogLevel.INFO, message, data);
  }

  public warn(message: string, data?: any): void {
    this.log(LogLevel.WARN, message, data);
  }

  public error(message: string, data?: any): void {
    this.log(LogLevel.ERROR, message, data);
  }

  private log(level: LogLevel, message: string, data?: any): void {
    if (level < this.logLevel) return;

    const timestamp = new Date().toISOString();
    const levelName = LogLevel[level];
    const logEntry = {
      timestamp,
      level: levelName,
      message,
      data
    };

    // 输出到控制台
    console.log(`[${timestamp}] ${levelName}: ${message}`, data || '');

    // 写入文件
    this.writeToFile(logEntry);
  }

  private writeToFile(logEntry: any): void {
    const logLine = JSON.stringify(logEntry) + '\n';

    try {
      // 检查文件大小
      if (fs.existsSync(this.logFile)) {
        const stats = fs.statSync(this.logFile);
        if (stats.size > this.maxLogSize) {
          this.rotateLogFile();
        }
      }

      fs.appendFileSync(this.logFile, logLine);
    } catch (error) {
      console.error('写入日志文件失败:', error);
    }
  }

  private rotateLogFile(): void {
    const backupFile = this.logFile + '.old';

    try {
      if (fs.existsSync(backupFile)) {
        fs.unlinkSync(backupFile);
      }
      fs.renameSync(this.logFile, backupFile);
    } catch (error) {
      console.error('日志文件轮转失败:', error);
    }
  }
}

// 导出全局日志实例
export const logger = new Logger();
```

## 8. 安全性设计

### 8.1 数据加密

```typescript
import * as crypto from 'crypto';

class SecurityManager {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;
  private readonly ivLength = 16;
  private readonly tagLength = 16;

  private encryptionKey: Buffer;

  constructor() {
    this.initializeEncryptionKey();
  }

  private initializeEncryptionKey(): void {
    const keyPath = path.join(app.getPath('userData'), '.key');

    try {
      if (fs.existsSync(keyPath)) {
        this.encryptionKey = fs.readFileSync(keyPath);
      } else {
        this.encryptionKey = crypto.randomBytes(this.keyLength);
        fs.writeFileSync(keyPath, this.encryptionKey, { mode: 0o600 });
      }
    } catch (error) {
      console.error('加密密钥初始化失败:', error);
      this.encryptionKey = crypto.randomBytes(this.keyLength);
    }
  }

  public encrypt(plaintext: string): string {
    try {
      const iv = crypto.randomBytes(this.ivLength);
      const cipher = crypto.createCipher(this.algorithm, this.encryptionKey, iv);

      let encrypted = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      const authTag = cipher.getAuthTag();

      // 组合 IV + 加密数据 + 认证标签
      const result = iv.toString('hex') + encrypted + authTag.toString('hex');
      return result;
    } catch (error) {
      console.error('加密失败:', error);
      throw new Error('数据加密失败');
    }
  }

  public decrypt(encryptedData: string): string {
    try {
      // 分离 IV、加密数据和认证标签
      const iv = Buffer.from(encryptedData.slice(0, this.ivLength * 2), 'hex');
      const authTag = Buffer.from(encryptedData.slice(-this.tagLength * 2), 'hex');
      const encrypted = encryptedData.slice(this.ivLength * 2, -this.tagLength * 2);

      const decipher = crypto.createDecipher(this.algorithm, this.encryptionKey, iv);
      decipher.setAuthTag(authTag);

      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      return decrypted;
    } catch (error) {
      console.error('解密失败:', error);
      throw new Error('数据解密失败');
    }
  }

  public hashPassword(password: string): string {
    const salt = crypto.randomBytes(16);
    const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512');
    return salt.toString('hex') + ':' + hash.toString('hex');
  }

  public verifyPassword(password: string, hashedPassword: string): boolean {
    const [salt, hash] = hashedPassword.split(':');
    const hashBuffer = crypto.pbkdf2Sync(password, Buffer.from(salt, 'hex'), 10000, 64, 'sha512');
    return hash === hashBuffer.toString('hex');
  }
}
```

### 8.2 进程保护

```typescript
class ProcessProtector {
  private isProtected = false;

  public enableProtection(): void {
    if (this.isProtected) return;

    // 防止调试器附加
    this.preventDebugging();

    // 监控进程完整性
    this.monitorProcessIntegrity();

    // 设置进程优先级
    this.setProcessPriority();

    this.isProtected = true;
    logger.info('进程保护已启用');
  }

  private preventDebugging(): void {
    if (process.env.NODE_ENV === 'production') {
      // 检测调试器
      setInterval(() => {
        if (process.debugPort || (global as any).v8debug) {
          logger.warn('检测到调试器，退出应用');
          app.quit();
        }
      }, 1000);

      // 禁用开发者工具
      app.on('web-contents-created', (event, contents) => {
        contents.on('devtools-opened', () => {
          contents.closeDevTools();
        });
      });
    }
  }

  private monitorProcessIntegrity(): void {
    // 监控关键文件完整性
    const criticalFiles = [
      path.join(__dirname, 'main.js'),
      path.join(__dirname, 'preload.js')
    ];

    criticalFiles.forEach(file => {
      if (fs.existsSync(file)) {
        const hash = this.calculateFileHash(file);
        // 存储并定期检查文件哈希
        this.scheduleIntegrityCheck(file, hash);
      }
    });
  }

  private calculateFileHash(filePath: string): string {
    const fileBuffer = fs.readFileSync(filePath);
    const hashSum = crypto.createHash('sha256');
    hashSum.update(fileBuffer);
    return hashSum.digest('hex');
  }

  private scheduleIntegrityCheck(filePath: string, originalHash: string): void {
    setInterval(() => {
      try {
        const currentHash = this.calculateFileHash(filePath);
        if (currentHash !== originalHash) {
          logger.error(`文件完整性检查失败: ${filePath}`);
          // 可以选择退出应用或采取其他保护措施
        }
      } catch (error) {
        logger.error(`完整性检查错误: ${error.message}`);
      }
    }, 60000); // 每分钟检查一次
  }

  private setProcessPriority(): void {
    try {
      // 设置高优先级
      process.setpriority(process.pid, -10);
    } catch (error) {
      logger.warn('设置进程优先级失败:', error.message);
    }
  }
}
```

## 9. 总结

本桌面端功能架构设计文档详细描述了 OfferHelper 桌面端应用的完整技术架构，包括：

### 9.1 核心特性

- **隐私保护**: 多层次的屏幕共享检测和自动隐藏机制
- **智能语音识别**: 实时监听和转录面试官问题
- **AI 分析引擎**: 快速生成专业的回答建议
- **知识库管理**: 本地化的面试知识存储和检索
- **用户体验**: 直观的悬浮窗口界面设计

### 9.2 技术亮点

- **跨平台兼容**: 支持 Windows、macOS、Linux
- **性能优化**: 内存管理、虚拟滚动、防抖节流
- **安全可靠**: 数据加密、进程保护、错误处理
- **模块化设计**: 清晰的架构分层和组件划分
- **事件驱动**: 完整的事件系统和状态管理

### 9.3 开发优势

- **易于维护**: 模块化的代码结构
- **可扩展性**: 插件化的功能设计
- **测试友好**: 完整的单元测试覆盖
- **文档完善**: 详细的技术文档和注释

该架构设计确保了桌面端应用能够在保护用户隐私的前提下，提供高效、稳定的面试辅助服务，为程序员面试成功提供有力支持。

# 桌面端功能架构设计

## 1. 整体架构概览

### 1.1 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    桌面端应用架构                              │
├─────────────────────────────────────────────────────────────┤
│  UI Layer (React + Electron Renderer)                      │
│  ├── 悬浮助手界面                                             │
│  ├── 设置面板                                               │
│  ├── 知识库界面                                             │
│  └── 状态指示器                                             │
├─────────────────────────────────────────────────────────────┤
│  Business Logic Layer                                      │
│  ├── 语音识别服务                                           │
│  ├── AI 分析引擎                                           │
│  ├── 知识库管理                                             │
│  ├── 面试助手核心                                           │
│  └── 用户数据管理                                           │
├─────────────────────────────────────────────────────────────┤
│  System Integration Layer                                  │
│  ├── 窗口管理器                                             │
│  ├── 隐私保护模块                                           │
│  ├── 快捷键管理                                             │
│  ├── 系统托盘                                               │
│  └── 文件系统接口                                           │
├─────────────────────────────────────────────────────────────┤
│  Data Layer                                                │
│  ├── 本地数据库 (SQLite)                                    │
│  ├── 缓存管理                                               │
│  ├── 配置存储                                               │
│  └── 日志系统                                               │
├─────────────────────────────────────────────────────────────┤
│  External Services                                         │
│  ├── AI API 服务                                           │
│  ├── 云端同步                                               │
│  ├── 更新服务                                               │
│  └── 统计分析                                               │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选择

- **主框架**: Electron 25+
- **UI 框架**: React 18 + TypeScript
- **状态管理**: Zustand
- **样式方案**: Tailwind CSS + Framer Motion
- **数据库**: SQLite + Prisma ORM
- **语音识别**: Web Speech API + 百度语音 API
- **AI 服务**: OpenAI API + 本地模型
- **构建工具**: Vite + Electron Builder

## 2. 核心模块设计

### 2.1 窗口管理器 (WindowManager)

```typescript
interface WindowConfig {
  width: number;
  height: number;
  x?: number;
  y?: number;
  alwaysOnTop: boolean;
  skipTaskbar: boolean;
  transparent: boolean;
  frame: boolean;
}

class WindowManager {
  private mainWindow: BrowserWindow | null = null;
  private settingsWindow: BrowserWindow | null = null;
  private isHidden: boolean = false;

  constructor() {
    this.initializeMainWindow();
    this.setupEventHandlers();
  }

  private initializeMainWindow(): void {
    const config: WindowConfig = {
      width: 400,
      height: 600,
      alwaysOnTop: true,
      skipTaskbar: true,
      transparent: true,
      frame: false
    };

    this.mainWindow = new BrowserWindow({
      ...config,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        webSecurity: false
      }
    });

    // 设置内容保护
    this.mainWindow.setContentProtection(true);

    // 加载应用
    this.mainWindow.loadFile('dist/index.html');
  }

  public toggleVisibility(): void {
    if (!this.mainWindow) return;

    if (this.isHidden) {
      this.show();
    } else {
      this.hide();
    }
  }

  public hide(): void {
    if (this.mainWindow && this.mainWindow.isVisible()) {
      this.mainWindow.hide();
      this.isHidden = true;
      this.notifyStatusChange('hidden');
    }
  }

  public show(): void {
    if (this.mainWindow && !this.mainWindow.isVisible()) {
      this.mainWindow.show();
      this.isHidden = false;
      this.notifyStatusChange('visible');
    }
  }

  private setupEventHandlers(): void {
    // 窗口事件处理
    this.mainWindow?.on('closed', () => {
      this.mainWindow = null;
    });

    // 全局快捷键
    globalShortcut.register('CommandOrControl+Shift+H', () => {
      this.toggleVisibility();
    });
  }

  private notifyStatusChange(status: 'hidden' | 'visible'): void {
    // 通知其他模块窗口状态变化
    EventBus.emit('window-status-changed', status);
  }
}
```

### 2.2 隐私保护模块 (PrivacyProtector)

```typescript
interface ScreenSharingApp {
  name: string;
  processName: string;
  windowTitle?: string;
}

class PrivacyProtector {
  private isMonitoring: boolean = false;
  private checkInterval: NodeJS.Timeout | null = null;
  private windowManager: WindowManager;

  private readonly SCREEN_SHARING_APPS: ScreenSharingApp[] = [
    { name: 'Zoom', processName: 'zoom.exe' },
    { name: 'Microsoft Teams', processName: 'Teams.exe' },
    { name: 'Skype', processName: 'Skype.exe' },
    { name: 'Google Chrome', processName: 'chrome.exe' },
    { name: 'Tencent Meeting', processName: 'wemeet.exe' },
    { name: 'DingTalk', processName: 'DingTalk.exe' }
  ];

  constructor(windowManager: WindowManager) {
    this.windowManager = windowManager;
  }

  public startMonitoring(): void {
    if (this.isMonitoring) return;

    this.isMonitoring = true;
    this.checkInterval = setInterval(async () => {
      await this.checkScreenSharing();
    }, 1000);

    console.log('隐私保护监控已启动');
  }

  public stopMonitoring(): void {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    this.isMonitoring = false;
    console.log('隐私保护监控已停止');
  }

  private async checkScreenSharing(): Promise<void> {
    try {
      const isSharing = await this.detectScreenSharing();

      if (isSharing) {
        this.windowManager.hide();
        this.showTrayNotification('检测到屏幕共享，助手已自动隐藏');
      }
    } catch (error) {
      console.error('屏幕共享检测失败:', error);
    }
  }

  private async detectScreenSharing(): Promise<boolean> {
    // 方法1: 检测进程
    const processDetection = await this.checkProcesses();

    // 方法2: 检测窗口标题
    const windowDetection = await this.checkWindowTitles();

    // 方法3: 检测系统API调用
    const apiDetection = await this.checkSystemAPIs();

    return processDetection || windowDetection || apiDetection;
  }

  private async checkProcesses(): Promise<boolean> {
    const { exec } = require('child_process');
    const util = require('util');
    const execAsync = util.promisify(exec);

    try {
      let command: string;

      if (process.platform === 'win32') {
        command = 'tasklist /fo csv | findstr /i "zoom\\|teams\\|skype\\|chrome\\|wemeet\\|dingtalk"';
      } else if (process.platform === 'darwin') {
        command = 'ps aux | grep -i "zoom\\|teams\\|skype\\|chrome\\|wemeet\\|dingtalk"';
      } else {
        command = 'ps aux | grep -i "zoom\\|teams\\|skype\\|chrome\\|wemeet\\|dingtalk"';
      }

      const { stdout } = await execAsync(command);
      return stdout.trim().length > 0;
    } catch (error) {
      return false;
    }
  }

  private async checkWindowTitles(): Promise<boolean> {
    // 使用 Electron 的 screen API 检测活动窗口
    const { screen } = require('electron');

    try {
      const sources = await desktopCapturer.getSources({
        types: ['window'],
        thumbnailSize: { width: 1, height: 1 }
      });

      const sharingKeywords = [
        '正在共享屏幕', '屏幕共享', 'Screen Sharing',
        'Zoom Meeting', 'Teams Meeting', 'Skype Call'
      ];

      return sources.some(source =>
        sharingKeywords.some(keyword =>
          source.name.toLowerCase().includes(keyword.toLowerCase())
        )
      );
    } catch (error) {
      return false;
    }
  }

  private async checkSystemAPIs(): Promise<boolean> {
    // 检测系统级屏幕捕获API调用
    if (process.platform === 'win32') {
      return this.checkWindowsScreenCapture();
    } else if (process.platform === 'darwin') {
      return this.checkMacOSScreenCapture();
    }
    return false;
  }

  private checkWindowsScreenCapture(): boolean {
    // 使用 Windows API 检测屏幕捕获
    try {
      const ffi = require('ffi-napi');
      const user32 = ffi.Library('user32', {
        'GetSystemMetrics': ['int', ['int']]
      });

      // 检测是否有应用正在捕获屏幕
      const captureFlag = user32.GetSystemMetrics(0x1000); // SM_REMOTESESSION
      return captureFlag > 0;
    } catch (error) {
      return false;
    }
  }

  private checkMacOSScreenCapture(): boolean {
    // 使用 macOS API 检测屏幕捕获
    try {
      const { execSync } = require('child_process');
      const result = execSync('system_profiler SPDisplaysDataType | grep -i "resolution"');
      // 简化的检测逻辑，实际应该更复杂
      return result.toString().includes('capture');
    } catch (error) {
      return false;
    }
  }

  private showTrayNotification(message: string): void {
    const { Notification } = require('electron');

    if (Notification.isSupported()) {
      new Notification({
        title: 'Offer
