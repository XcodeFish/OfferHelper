# 桌面端项目结构设计与开发规范

## 1. 项目结构设计

### 1.1 整体目录结构

```
OfferHelper-Desktop/
├── src/                          # 源代码目录
│   ├── main/                     # 主进程代码
│   │   ├── main.ts              # 主进程入口文件
│   │   ├── window/              # 窗口管理
│   │   │   ├── WindowManager.ts
│   │   │   └── WindowConfig.ts
│   │   ├── privacy/             # 隐私保护
│   │   │   ├── PrivacyProtector.ts
│   │   │   └── ScreenDetector.ts
│   │   ├── services/            # 主进程服务
│   │   │   ├── UpdateService.ts
│   │   │   ├── ConfigService.ts
│   │   │   └── DatabaseService.ts
│   │   ├── security/            # 安全模块
│   │   │   ├── SecurityManager.ts
│   │   │   └── ProcessProtector.ts
│   │   └── utils/               # 主进程工具
│   │       ├── Logger.ts
│   │       └── ErrorHandler.ts
│   ├── renderer/                # 渲染进程代码
│   │   ├── index.tsx           # 渲染进程入口
│   │   ├── App.tsx             # 主应用组件
│   │   ├── components/         # UI组件
│   │   │   ├── common/         # 通用组件
│   │   │   │   ├── Button/
│   │   │   │   ├── Modal/
│   │   │   │   └── Loading/
│   │   │   ├── layout/         # 布局组件
│   │   │   │   ├── TitleBar/
│   │   │   │   ├── StatusBar/
│   │   │   │   └── ControlPanel/
│   │   │   ├── features/       # 功能组件
│   │   │   │   ├── QuestionDisplay/
│   │   │   │   ├── AnswerPanel/
│   │   │   │   ├── KnowledgeBase/
│   │   │   │   └── Settings/
│   │   │   └── animations/     # 动画组件
│   │   │       └── Transitions/
│   │   ├── hooks/              # 自定义Hooks
│   │   │   ├── useAppState.ts
│   │   │   ├── useSpeechRecognition.ts
│   │   │   ├── useAIAnalysis.ts
│   │   │   └── usePrivacyProtection.ts
│   │   ├── services/           # 渲染进程服务
│   │   │   ├── SpeechService.ts
│   │   │   ├── AIService.ts
│   │   │   └── KnowledgeService.ts
│   │   ├── store/              # 状态管理
│   │   │   ├── index.ts
│   │   │   ├── slices/
│   │   │   │   ├── appSlice.ts
│   │   │   │   ├── speechSlice.ts
│   │   │   │   └── aiSlice.ts
│   │   │   └── types.ts
│   │   ├── styles/             # 样式文件
│   │   │   ├── globals.css
│   │   │   ├── components/
│   │   │   └── themes/
│   │   └── utils/              # 渲染进程工具
│   │       ├── constants.ts
│   │       ├── helpers.ts
│   │       └── validators.ts
│   ├── shared/                 # 共享代码
│   │   ├── types/              # 类型定义
│   │   │   ├── index.ts
│   │   │   ├── window.ts
│   │   │   ├── speech.ts
│   │   │   └── ai.ts
│   │   ├── constants/          # 常量定义
│   │   │   ├── index.ts
│   │   │   ├── events.ts
│   │   │   └── config.ts
│   │   ├── utils/              # 共享工具
│   │   │   ├── EventBus.ts
│   │   │   ├── crypto.ts
│   │   │   └── validation.ts
│   │   └── interfaces/         # 接口定义
│   │       ├── IWindowManager.ts
│   │       ├── ISpeechService.ts
│   │       └── IAIService.ts
│   └── preload/                # 预加载脚本
│       ├── index.ts
│       └── api.ts
├── resources/                   # 资源文件
│   ├── icons/                  # 图标文件
│   │   ├── icon.ico
│   │   ├── icon.icns
│   │   └── icon.png
│   ├── sounds/                 # 音频文件
│   └── data/                   # 数据文件
│       └── knowledge-base.json
├── build/                      # 构建配置
│   ├── icon.ico
│   ├── icon.icns
│   ├── icon.png
│   ├── entitlements.mac.plist
│   └── dmg-background.png
├── scripts/                    # 构建脚本
│   ├── build.js
│   ├── dev.js
│   ├── security-check.js
│   └── release.js
├── tests/                      # 测试文件
│   ├── unit/                   # 单元测试
│   │   ├── main/
│   │   └── renderer/
│   ├── integration/            # 集成测试
│   ├── e2e/                    # 端到端测试
│   └── fixtures/               # 测试数据
├── docs/                       # 文档目录
│   ├── api/                    # API文档
│   ├── guides/                 # 使用指南
│   └── architecture/           # 架构文档
├── .github/                    # GitHub配置
│   ├── workflows/              # CI/CD工作流
│   │   ├── build.yml
│   │   ├── test.yml
│   │   └── release.yml
│   └── ISSUE_TEMPLATE/         # Issue模板
├── config/                     # 配置文件
│   ├── webpack.main.config.js
│   ├── webpack.renderer.config.js
│   ├── jest.config.js
│   ├── eslint.config.js
│   └── prettier.config.js
├── package.json                # 项目配置
├── tsconfig.json              # TypeScript配置
├── electron-builder.json      # 打包配置
├── .gitignore                 # Git忽略文件
├── .env.example               # 环境变量示例
├── README.md                  # 项目说明
└── LICENSE                    # 许可证
```

### 1.2 核心模块结构

#### 1.2.1 主进程模块 (src/main/)

```typescript
// src/main/main.ts - 主进程入口
import { app, BrowserWindow } from 'electron';
import { WindowManager } from './window/WindowManager';
import { PrivacyProtector } from './privacy/PrivacyProtector';
import { UpdateService } from './services/UpdateService';
import { SecurityManager } from './security/SecurityManager';
import { logger } from './utils/Logger';

class Application {
  private windowManager: WindowManager;
  private privacyProtector: PrivacyProtector;
  private updateService: UpdateService;
  private securityManager: SecurityManager;

  constructor() {
    this.initializeApplication();
  }

  private async initializeApplication(): Promise<void> {
    await app.whenReady();

    this.securityManager = new SecurityManager();
    this.windowManager = new WindowManager();
    this.privacyProtector = new PrivacyProtector(this.windowManager);
    this.updateService = new UpdateService();

    this.setupEventHandlers();
    this.startServices();
  }

  private setupEventHandlers(): void {
    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });

    app.on('activate', () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        this.windowManager.createMainWindow();
      }
    });
  }

  private startServices(): void {
    this.privacyProtector.startMonitoring();
    this.updateService.checkForUpdates();
    logger.info('应用程序启动完成');
  }
}

new Application();
```

#### 1.2.2 渲染进程模块 (src/renderer/)

```typescript
// src/renderer/App.tsx - 主应用组件
import React from 'react';
import { ThemeProvider } from './contexts/ThemeContext';
import { AppStateProvider } from './contexts/AppStateContext';
import { MainLayout } from './components/layout/MainLayout';
import { ErrorBoundary } from './components/common/ErrorBoundary';
import './styles/globals.css';

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <ThemeProvider>
        <AppStateProvider>
          <MainLayout />
        </AppStateProvider>
      </ThemeProvider>
    </ErrorBoundary>
  );
};

export default App;
```

#### 1.2.3 共享模块 (src/shared/)

```typescript
// src/shared/types/index.ts - 类型定义
export interface WindowConfig {
  width: number;
  height: number;
  x?: number;
  y?: number;
  alwaysOnTop: boolean;
  skipTaskbar: boolean;
  transparent: boolean;
  frame: boolean;
}

export interface SpeechConfig {
  language: string;
  continuous: boolean;
  interimResults: boolean;
  maxAlternatives: number;
}

export interface AIResponse {
  answer: string;
  confidence: number;
  keywords: string[];
  category: string;
  suggestions: string[];
}

export interface AppState {
  ui: UIState;
  speech: SpeechState;
  ai: AIState;
  privacy: PrivacyState;
  system: SystemState;
}
```

## 2. 开发规范

### 2.1 代码规范

#### 2.1.1 TypeScript 规范

```typescript
// 1. 严格的类型定义
interface UserConfig {
  readonly id: string;
  name: string;
  settings: {
    theme: 'dark' | 'light';
    language: 'zh-CN' | 'en-US';
  };
}

// 2. 使用泛型提高代码复用性
class DataService<T> {
  private data: T[] = [];

  public add(item: T): void {
    this.data.push(item);
  }

  public getById(id: string): T | undefined {
    return this.data.find(item => (item as any).id === id);
  }
}

// 3. 使用枚举定义常量
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

// 4. 使用联合类型限制取值
type WindowState = 'hidden' | 'visible' | 'minimized';

// 5. 使用工具类型
type PartialConfig = Partial<UserConfig>;
type RequiredSettings = Required<UserConfig['settings']>;
```

#### 2.1.2 命名规范

```typescript
// 1. 文件命名：PascalCase for components, camelCase for utilities
// ✅ 正确
WindowManager.ts
SpeechService.ts
userHelpers.ts
configUtils.ts

// ❌ 错误
windowmanager.ts
speech_service.ts
UserHelpers.ts

// 2. 类命名：PascalCase
class WindowManager {
  private mainWindow: BrowserWindow | null = null;
}

// 3. 接口命名：以 I 开头的 PascalCase
interface IWindowManager {
  createWindow(): void;
  closeWindow(): void;
}

// 4. 常量命名：SCREAMING_SNAKE_CASE
const MAX_RETRY_COUNT = 3;
const DEFAULT_WINDOW_CONFIG = {
  width: 800,
  height: 600
};

// 5. 函数命名：camelCase，动词开头
function createMainWindow(): BrowserWindow { }
function validateUserInput(input: string): boolean { }
function handleWindowClose(): void { }

// 6. 变量命名：camelCase，名词性
const currentUser = getCurrentUser();
const windowConfig = getWindowConfig();
const isWindowVisible = checkWindowVisibility();
```

#### 2.1.3 代码组织规范

```typescript
// 1. 导入顺序
// 第三方库
import React, { useState, useEffect } from 'react';
import { BrowserWindow, app } from 'electron';
import axios from 'axios';

// 内部模块 - 按层级顺序
import { WindowManager } from '../window/WindowManager';
import { SpeechService } from '../services/SpeechService';
import { logger } from '../utils/Logger';

// 类型定义
import type { WindowConfig, SpeechConfig } from '../types';

// 2. 类结构顺序
class WindowManager {
  // 静态属性
  private static instance: WindowManager;

  // 实例属性
  private mainWindow: BrowserWindow | null = null;
  private config: WindowConfig;

  // 构造函数
  constructor(config: WindowConfig) {
    this.config = config;
  }

  // 静态方法
  public static getInstance(): WindowManager {
    if (!WindowManager.instance) {
      WindowManager.instance = new WindowManager(defaultConfig);
    }
    return WindowManager.instance;
  }

  // 公共方法
  public createWindow(): void {
    // 实现
  }

  // 私有方法
  private setupEventHandlers(): void {
    // 实现
  }
}

// 3. React 组件结构
const MainWindow: React.FC<MainWindowProps> = ({
  title,
  onClose
}) => {
  // Hooks
  const [isVisible, setIsVisible] = useState(true);
  const [config, setConfig] = useState<WindowConfig>(defaultConfig);

  // Effects
  useEffect(() => {
    // 副作用逻辑
  }, []);

  // 事件处理函数
  const handleClose = useCallback(() => {
    onClose?.();
  }, [onClose]);

  // 渲染函数
  const renderContent = () => {
    return <div>Content</div>;
  };

  // 主渲染
  return (
    <div className="main-window">
      {renderContent()}
    </div>
  );
};
```

### 2.2 项目配置规范

#### 2.2.1 TypeScript 配置

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/main/*": ["src/main/*"],
      "@/renderer/*": ["src/renderer/*"],
      "@/shared/*": ["src/shared/*"]
    }
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "build"
  ]
}
```

#### 2.2.2 ESLint 配置

```javascript
// eslint.config.js
module.exports = {
  root: true,
  env: {
    browser: true,
    es6: true,
    node: true
  },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:@typescript-eslint/recommended'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true
    },
    ecmaVersion: 2020,
    sourceType: 'module'
  },
  plugins: [
    'react',
    '@typescript-eslint'
  ],
  rules: {
    // TypeScript 规则
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-non-null-assertion': 'error',

    // React 规则
    'react/prop-types': 'off',
    'react/react-in-jsx-scope': 'off',
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn',

    // 通用规则
    'no-console': 'warn',
    'no-debugger': 'error',
    'prefer-const': 'error',
    'no-var': 'error',
    'eqeqeq': 'error',
    'curly': 'error'
  },
  settings: {
    react: {
      version: 'detect'
    }
  }
};
```

#### 2.2.3 Prettier 配置

```javascript
// prettier.config.js
module.exports = {
  semi: true,
  trailingComma: 'es5',
  singleQuote: true,
  printWidth: 80,
  tabWidth: 2,
  useTabs: false,
  bracketSpacing: true,
  bracketSameLine: false,
  arrowParens: 'avoid',
  endOfLine: 'lf',
  overrides: [
    {
      files: '*.json',
      options: {
        printWidth: 120
      }
    }
  ]
};
```

### 2.3 Git 工作流规范

#### 2.3.1 分支管理

```bash
# 主分支
main          # 生产环境分支，只接受来自 release 分支的合并
develop       # 开发分支，功能开发的基础分支

# 功能分支
feature/      # 功能开发分支
├── feature/speech-recognition
├── feature/ai-analysis
└── feature/privacy-protection

# 修复分支
hotfix/       # 紧急修复分支
├── hotfix/critical-bug-fix
└── hotfix/security-patch

# 发布分支
release/      # 发布准备分支
├── release/v1.0.0
└── release/v1.1.0
```

#### 2.3.2 提交信息规范

```bash
# 提交信息格式
<type>(<scope>): <subject>

<body>

<footer>

# 类型说明
feat:     新功能
fix:      修复问题
docs:     文档更新
style:    代码格式调整（不影响功能）
refactor: 代码重构
test:     测试相关
chore:    构建过程或辅助工具的变动
perf:     性能优化
ci:       CI/CD 相关

# 示例
feat(speech): 添加语音识别功能

- 集成 Web Speech API
- 支持中英文识别
- 添加识别结果处理逻辑

Closes #123

fix(privacy): 修复屏幕共享检测问题

修复在 macOS 系统下屏幕共享检测不准确的问题

Breaking Change: 更改了 PrivacyProtector 的 API 接口
```

### 2.4 测试规范

#### 2.4.1 单元测试

```typescript
// tests/unit/main/WindowManager.test.ts
import { WindowManager } from '../../../src/main/window/WindowManager';
import { BrowserWindow } from 'electron';

// Mock Electron
jest.mock('electron', () => ({
  BrowserWindow: jest.fn().mockImplementation(() => ({
    loadFile: jest.fn(),
    on: jest.fn(),
    show: jest.fn(),
    hide: jest.fn(),
    isVisible: jest.fn().mockReturnValue(true)
  }))
}));

describe('WindowManager', () => {
  let windowManager: WindowManager;

  beforeEach(() => {
    windowManager = new WindowManager();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createMainWindow', () => {
    it('should create a main window with correct configuration', () => {
      windowManager.createMainWindow();

      expect(BrowserWindow).toHaveBeenCalledWith({
        width: 400,
        height: 600,
        alwaysOnTop: true,
        skipTaskbar: true,
        transparent: true,
        frame: false,
        webPreferences: {
          nodeIntegration: true,
          contextIsolation: false,
          webSecurity: false
        }
      });
    });
  });

  describe('toggleVisibility', () => {
    it('should hide window when visible', () => {
      const mockWindow = {
        isVisible: jest.fn().mockReturnValue(true),
        hide: jest.fn(),
        show: jest.fn()
      };

      (windowManager as any).mainWindow = mockWindow;
      windowManager.toggleVisibility();

      expect(mockWindow.hide).toHaveBeenCalled();
      expect(mockWindow.show).not.toHaveBeenCalled();
    });

    it('should show window when hidden', () => {
      const mockWindow = {
        isVisible: jest.fn().mockReturnValue(false),
        hide: jest.fn(),
        show: jest.fn()
      };

      (windowManager as any).mainWindow = mockWindow;
      windowManager.toggleVisibility();

      expect(mockWindow.show).toHaveBeenCalled();
      expect(mockWindow.hide).not.toHaveBeenCalled();
    });
  });
});
```

#### 2.4.2 集成测试

```typescript
// tests/integration/SpeechToAI.test.ts
import { SpeechRecognitionService } from '../../src/renderer/services/SpeechService';
import { AIAnalysisEngine } from '../../src/renderer/services/AIService';
import { EventBus } from '../../src/shared/utils/EventBus';

describe('Speech to AI Integration', () => {
  let speechService: SpeechRecognitionService;
  let aiEngine: AIAnalysisEngine;

  beforeEach(() => {
    speechService = new SpeechRecognitionService();
    aiEngine = new AIAnalysisEngine();
  });

  it('should process speech result through AI analysis', async () => {
    const mockQuestion = '请介绍一下你的项目经验';
    const mockAIResponse = {
      answer: '我在之前的工作中...',
      confidence: 0.9,
      keywords: ['项目', '经验'],
      category: 'behavioral',
      suggestions: ['结合具体项目案例']
    };

    // Mock AI service
    jest.spyOn(aiEngine, 'analyzeQuestion').mockResolvedValue(mockAIResponse);

    // Simulate speech recognition result
    EventBus.emit('speech-final-result', mockQuestion);

    // Wait for AI analysis
    await new Promise(resolve => setTimeout(resolve, 100));

    expect(aiEngine.analyzeQuestion).toHaveBeenCalledWith(mockQuestion);
  });
});
```

#### 2.4.3 E2E 测试

```typescript
// tests/e2e/main-workflow.spec.ts
import { test, expect } from '@playwright/test';
import { ElectronApplication, _electron as electron } from 'playwright';

test.describe('Main Workflow', () => {
  let electronApp: ElectronApplication;

  test.beforeAll(async () => {
    electronApp = await electron.launch({
      args: ['dist/main.js']
    });
  });

  test.afterAll(async () => {
    await electronApp.close();
  });

  test('should launch application and show main window', async () => {
    const window = await electronApp.firstWindow();

    await expect(window).toHaveTitle('OfferHelper');

    // Check if main components are visible
    await expect(window.locator('.status-bar')).toBeVisible();
    await expect(window.locator('.control-panel')).toBeVisible();
  });

  test('should toggle listening state', async () => {
    const window = await electronApp.firstWindow();

    const listenButton = window.locator('[data-testid="listen-button"]');

    // Start listening
    await listenButton.click();
    await expect(listenButton).toHaveText('停止监听');

    // Stop listening
    await listenButton.click();
    await expect(listenButton).toHaveText('开始监听');
  });

  test('should hide window when screen sharing detected', async () => {
    const window = await electronApp.firstWindow();

    // Simulate screen sharing detection
    await electronApp.evaluate(({ app }) => {
      // Trigger privacy protection
      app.emit('screen-sharing-detected');
    });

    // Window should be hidden
    await expect(window).toBeHidden();
  });
});
```

### 2.5 文档规范

#### 2.5.1 代码注释规范

```typescript
/**
 * 窗口管理器类
 * 负责管理应用程序的所有窗口，包括主窗口、设置窗口等
 *
 * @example
 * ```typescript
 * const windowManager = new WindowManager();
 * windowManager.createMainWindow();
 * ```
 */
class WindowManager {
  private mainWindow: BrowserWindow | null = null;

  /**
   * 创建主窗口
   *
   * @param config - 窗口配置选项
   * @returns 创建的窗口实例
   *
   * @throws {Error} 当窗口创建失败时抛出错误
   *
   * @example
   * ```typescript
   * const window = windowManager.createMainWindow({
   *   width: 800,
   *   height: 600
   * });
   * ```
   */
  public createMainWindow(config?: Partial<WindowConfig>): BrowserWindow {
    // 实现逻辑
  }

  /**
   * 切换窗口可见性
   * 如果窗口当前可见，则隐藏；如果隐藏，则显示
   *
   * @internal 内部方法，不对外暴露
   */
  private toggleVisibility(): void {
    // 实现逻辑
  }
}

/**
 * 语音识别配置接口
 */
interface SpeechConfig {
  /** 识别语言，默认为 'zh-CN' */
  language: string;
  /** 是否连续识别，默认为 true */
  continuous: boolean;
  /** 是否返回中间结果，默认为 true */
  interimResults: boolean;
  /** 最大候选结果数量，默认为 3 */
  maxAlternatives: number;
}
```

#### 2.5.2 API 文档规范

```markdown
# WindowManager API

## 类: WindowManager

窗口管理器，负责管理应用程序的所有窗口。

### 构造函数

#### `new WindowManager(config?: WindowConfig)`

创建窗口管理器实例。

**参数:**
- `config` (可选) - 窗口配置对象

**示例:**
```typescript
const windowManager = new WindowManager({
  width: 800,
  height: 600
});
```

### 方法

#### `createMainWindow(config?: Partial<WindowConfig>): BrowserWindow`

创建主应用窗口。

**参数:**

- `config` (可选) - 窗口配置选项

**返回值:**

- `BrowserWindow` - 创建的窗口实例

**抛出异常:**

- `Error` - 当窗口创建失败时

**示例:**

```typescript
const mainWindow = windowManager.createMainWindow({
  alwaysOnTop: true,
  transparent: true
});
```

#### `hide(): void`

隐藏主窗口。

**示例:**

```typescript
windowManager.hide();
```

#### `show(): void`

显示主窗口。

**示例:**

```typescript
windowManager.show();
```

### 事件

#### `window-status-changed`

当窗口状态发生变化时触发。

**回调参数:**

- `status: 'hidden' | 'visible'` - 窗口状态

**示例:**

```typescript
EventBus.on('window-status-changed', (status) => {
  console.log('窗口状态变化:', status);
});
```

```

### 2.6 性能规范

#### 2.6.1 内存管理

```typescript
// 1. 及时清理事件监听器
class ComponentManager {
  private eventListeners: Array<() => void> = [];

  public addEventListeners(): void {
    const listener = () => { /* 处理逻辑 */ };
    EventBus.on('some-event', listener);

    // 保存清理函数
    this.eventListeners.push(() => {
      EventBus.off('some-event', listener);
    });
  }

  public cleanup(): void {
    // 清理所有事件监听器
    this.eventListeners.forEach(cleanup => cleanup());
    this.eventListeners = [];
  }
}

// 2. 使用 WeakMap 避免内存泄漏
const componentInstances = new WeakMap<HTMLElement, ComponentInstance>();

// 3. 及时释放大对象引用
class DataProcessor {
  private largeDataSet: any[] | null = null;

  public processData(data: any[]): void {
    this.largeDataSet = data;
    // 处理完成后立即释放
    this.cleanup();
  }

  private cleanup(): void {
    this.largeDataSet = null;
  }
}
```

#### 2.6.2 渲染性能

```typescript
// 1. 使用 React.memo 优化组件渲染
const ExpensiveComponent = React.memo<ExpensiveComponentProps>(({
  data,
  onUpdate
}) => {
  return (
    <div>
      {/* 复杂的渲染逻辑 */}
    </div>
  );
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return prevProps.data.id === nextProps.data.id;
});

// 2. 使用 useMemo 缓存计算结果
const DataVisualization: React.FC<DataVisualizationProps> = ({ rawData }) => {
  const processedData = useMemo(() => {
    return rawData.map(item => ({
      ...item,
      computed: expensiveCalculation(item)
    }));
  }, [rawData]);

  return <Chart data={processedData} />;
};

// 3. 使用 useCallback 缓存事件处理函数
const InteractiveComponent: React.FC = () => {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  const handleReset = useCallback(() => {
    setCount(0);
  }, []);

  return (
    <div>
      <button onClick={handleClick}>Count: {count}</button>
      <button onClick={handleReset}>Reset</button>
    </div>
  );
};

// 4. 虚拟滚动优化长列表
const VirtualizedList: React.FC<VirtualizedListProps> = ({
  items,
  itemHeight,
  containerHeight
}) => {
  const [scrollTop, setScrollTop] = useState(0);

  const visibleItems = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + 2,
      items.length
    );
    return items.slice(startIndex, endIndex);
  }, [items, scrollTop, itemHeight, containerHeight]);

  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={e => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map((item, index) => (
          <div
            key={item.id}
            style={{
              position: 'absolute',
              top: (Math.floor(scrollTop / itemHeight) + index) * itemHeight,
              height: itemHeight
            }}
          >
            <ListItem data={item} />
          </div>
        ))}
      </div>
    </div>
  );
};
```

#### 2.6.3 启动性能

```typescript
// 1. 延迟加载非关键模块
class Application {
  private async initializeApplication(): Promise<void> {
    // 优先加载核心模块
    await this.loadCoreModules();

    // 延迟加载次要模块
    setTimeout(() => {
      this.loadSecondaryModules();
    }, 1000);
  }

  private async loadCoreModules(): Promise<void> {
    this.windowManager = new WindowManager();
    this.privacyProtector = new PrivacyProtector(this.windowManager);
  }

  private async loadSecondaryModules(): Promise<void> {
    const { UpdateService } = await import('./services/UpdateService');
    const { AnalyticsService } = await import('./services/AnalyticsService');

    this.updateService = new UpdateService();
    this.analyticsService = new AnalyticsService();
  }
}

// 2. 预编译模板和资源
const precompiledTemplates = {
  mainWindow: require('./templates/mainWindow.html'),
  settingsWindow: require('./templates/settingsWindow.html')
};

// 3. 使用 Web Workers 处理耗时任务
class BackgroundProcessor {
  private worker: Worker;

  constructor() {
    this.worker = new Worker('./workers/dataProcessor.js');
    this.setupWorkerHandlers();
  }

  public processLargeDataset(data: any[]): Promise<any[]> {
    return new Promise((resolve, reject) => {
      this.worker.postMessage({ type: 'PROCESS_DATA', data });

      this.worker.onmessage = (event) => {
        if (event.data.type === 'PROCESS_COMPLETE') {
          resolve(event.data.result);
        } else if (event.data.type === 'PROCESS_ERROR') {
          reject(new Error(event.data.error));
        }
      };
    });
  }
}
```

### 2.7 安全规范

#### 2.7.1 输入验证

```typescript
// 1. 严格的输入验证
class InputValidator {
  public static validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email) && email.length <= 254;
  }

  public static validatePassword(password: string): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    if (password.length < 8) {
      errors.push('密码长度至少8位');
    }

    if (!/[A-Z]/.test(password)) {
      errors.push('密码必须包含大写字母');
    }

    if (!/[a-z]/.test(password)) {
      errors.push('密码必须包含小写字母');
    }

    if (!/\d/.test(password)) {
      errors.push('密码必须包含数字');
    }

    if (!/[!@#$%^&*]/.test(password)) {
      errors.push('密码必须包含特殊字符');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  public static sanitizeInput(input: string): string {
    return input
      .replace(/[<>]/g, '') // 移除潜在的HTML标签
      .replace(/javascript:/gi, '') // 移除JavaScript协议
      .trim()
      .substring(0, 1000); // 限制长度
  }
}

// 2. API 请求验证
class APIClient {
  private validateRequest(url: string, data: any): void {
    // 验证URL
    if (!url.startsWith('https://')) {
      throw new Error('只允许HTTPS请求');
    }

    // 验证数据大小
    const dataSize = JSON.stringify(data).length;
    if (dataSize > 1024 * 1024) { // 1MB
      throw new Error('请求数据过大');
    }

    // 验证数据结构
    if (typeof data !== 'object' || data === null) {
      throw new Error('无效的请求数据');
    }
  }

  public async post(url: string, data: any): Promise<any> {
    this.validateRequest(url, data);

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return response.json();
  }
}
```

#### 2.7.2 数据保护

```typescript
// 1. 敏感数据加密存储
class SecureStorage {
  private encryptionKey: string;

  constructor() {
    this.encryptionKey = this.generateEncryptionKey();
  }

  public setItem(key: string, value: any): void {
    const serialized = JSON.stringify(value);
    const encrypted = this.encrypt(serialized);
    localStorage.setItem(key, encrypted);
  }

  public getItem<T>(key: string): T | null {
    const encrypted = localStorage.getItem(key);
    if (!encrypted) return null;

    try {
      const decrypted = this.decrypt(encrypted);
      return JSON.parse(decrypted);
    } catch (error) {
      console.error('解密失败:', error);
      return null;
    }
  }

  private encrypt(text: string): string {
    // 使用 AES 加密
    const CryptoJS = require('crypto-js');
    return CryptoJS.AES.encrypt(text, this.encryptionKey).toString();
  }

  private decrypt(encryptedText: string): string {
    const CryptoJS = require('crypto-js');
    const bytes = CryptoJS.AES.decrypt(encryptedText, this.encryptionKey);
    return bytes.toString(CryptoJS.enc.Utf8);
  }

  private generateEncryptionKey(): string {
    // 基于设备信息生成密钥
    const { machineId } = require('node-machine-id');
    return machineId();
  }
}

// 2. 敏感信息脱敏
class DataMasker {
  public static maskEmail(email: string): string {
    const [username, domain] = email.split('@');
    const maskedUsername = username.substring(0, 2) + '*'.repeat(username.length - 2);
    return `${maskedUsername}@${domain}`;
  }

  public static maskPhone(phone: string): string {
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }

  public static maskCreditCard(cardNumber: string): string {
    return cardNumber.replace(/\d(?=\d{4})/g, '*');
  }
}
```

### 2.8 错误处理规范

#### 2.8.1 错误分类

```typescript
// 1. 自定义错误类型
export class AppError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly isOperational: boolean;

  constructor(
    message: string,
    code: string,
    statusCode: number = 500,
    isOperational: boolean = true
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, field?: string) {
    super(message, 'VALIDATION_ERROR', 400);
    this.field = field;
  }
}

export class NetworkError extends AppError {
  constructor(message: string, originalError?: Error) {
    super(message, 'NETWORK_ERROR', 503);
    this.originalError = originalError;
  }
}

export class PermissionError extends AppError {
  constructor(message: string) {
    super(message, 'PERMISSION_ERROR', 403);
  }
}

// 2. 错误处理中间件
class ErrorHandler {
  public static handle(error: Error, context?: string): void {
    // 记录错误
    logger.error('应用错误', {
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    });

    // 发送到监控服务
    if (process.env.NODE_ENV === 'production') {
      this.sendToMonitoring(error, context);
    }

    // 用户通知
    if (error instanceof AppError && error.isOperational) {
      this.notifyUser(error);
    } else {
      this.notifyUser(new AppError('发生了未知错误，请重试', 'UNKNOWN_ERROR'));
    }
  }

  private static sendToMonitoring(error: Error, context?: string): void {
    // 发送到 Sentry 或其他监控服务
    // Sentry.captureException(error, { extra: { context } });
  }

  private static notifyUser(error: AppError): void {
    // 显示用户友好的错误消息
    const notification = new Notification({
      title: '错误提示',
      body: error.message,
      icon: path.join(__dirname, 'assets/error-icon.png')
    });

    notification.show();
  }
}

// 3. 全局错误捕获
process.on('uncaughtException', (error: Error) => {
  logger.error('未捕获的异常:', error);
  ErrorHandler.handle(error, 'uncaughtException');

  // 优雅关闭应用
  process.exit(1);
});

process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
  logger.error('未处理的Promise拒绝:', { reason, promise });
  ErrorHandler.handle(new Error(String(reason)), 'unhandledRejection');
});
```

#### 2.8.2 错误恢复策略

```typescript
// 1. 重试机制
class RetryableOperation {
  private maxRetries: number = 3;
  private retryDelay: number = 1000;

  public async execute<T>(
    operation: () => Promise<T>,
    retries: number = this.maxRetries
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      if (retries > 0 && this.isRetryableError(error)) {
        logger.warn(`操作失败，${this.retryDelay}ms后重试，剩余重试次数: ${retries - 1}`);

        await this.delay(this.retryDelay);
        return this.execute(operation, retries - 1);
      }

      throw error;
    }
  }

  private isRetryableError(error: any): boolean {
    // 网络错误、超时错误等可以重试
    return error instanceof NetworkError ||
           error.code === 'ECONNRESET' ||
           error.code === 'ETIMEDOUT';
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// 2. 断路器模式
class CircuitBreaker {
  private failureCount: number = 0;
  private lastFailureTime: number = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';

  constructor(
    private failureThreshold: number = 5,
    private recoveryTimeout: number = 60000
  ) {}

  public async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.recoveryTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('断路器开启，服务暂时不可用');
      }
    }

    try {
      const result = await operation();

      // 成功时重置状态
      if (this.state === 'HALF_OPEN') {
        this.state = 'CLOSED';
        this.failureCount = 0;
      }

      return result;
    } catch (error) {
      this.failureCount++;
      this.lastFailureTime = Date.now();

      if (this.failureCount >= this.failureThreshold) {
        this.state = 'OPEN';
      }

      throw error;
    }
  }
}
```

## 3. 开发工具配置

### 3.1 VS Code 配置

```json
// .vscode/settings.json
{
  "typescript.preferences.importModuleSpecifier": "relative",
  "typescript.suggest.autoImports": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true,
    "source.organizeImports": true
  },
  "files.associations": {
    "*.tsx": "typescriptreact",
    "*.ts": "typescript"
  },
  "emmet.includeLanguages": {
    "typescript": "html",
    "typescriptreact": "html"
  },
  "search.exclude": {
    "**/node_modules": true,
    "**/dist": true,
    "**/build": true,
    "**/.git": true
  },
  "files.watcherExclude": {
    "**/node_modules/**": true,
    "**/dist/**": true,
    "**/build/**": true
  }
}

// .vscode/extensions.json
{
  "recommendations": [
    "ms-vscode.vscode-typescript-next",
    "esbenp.prettier-vscode",
    "dbaeumer.vscode-eslint",
    "bradlc.vscode-tailwindcss",
    "ms-vscode.vscode-json",
    "formulahendry.auto-rename-tag",
    "christian-kohler.path-intellisense",
    "ms-vscode.vscode-jest"
  ]
}

// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Main Process",
      "type": "node",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "runtimeExecutable": "${workspaceFolder}/node_modules/.bin/electron",
      "windows": {
        "runtimeExecutable": "${workspaceFolder}/node_modules/.bin/electron.cmd"
      },
      "args": ["dist/main.js"],
      "outputCapture": "std",
      "console": "integratedTerminal",
      "protocol": "inspector"
    },
    {
      "name": "Debug Renderer Process",
      "type": "chrome",
      "request": "attach",
      "port": 9222,
      "webRoot": "${workspaceFolder}/src/renderer",
      "timeout": 30000
    }
  ]
}
```

### 3.2 开发脚本

```json
// package.json scripts
{
  "scripts": {
    "dev": "concurrently \"npm run dev:main\" \"npm run dev:renderer\"",
    "dev:main": "webpack --config config/webpack.main.config.js --mode development --watch",
    "dev:renderer": "webpack serve --config config/webpack.renderer.config.js --mode development",
    "build": "npm run build:main && npm run build:renderer",
    "build:main": "webpack --config config/webpack.main.config.js --mode production",
    "build:renderer": "webpack --config config/webpack.renderer.config.js --mode production",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "lint": "eslint src --ext .ts,.tsx",
    "lint:fix": "eslint src --ext .ts,.tsx --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,css,md}\"",
    "type-check": "tsc --noEmit",
    "security-check": "node scripts/security-check.js",
    "dist": "npm run build && electron-builder",
    "dist:mac": "npm run build && electron-builder --mac",
    "dist:win": "npm run build && electron-builder --win",
    "dist:linux": "npm run build && electron-builder --linux",
    "release": "npm run test && npm run security-check && npm run dist",
    "clean": "rimraf dist build release",
    "postinstall": "electron-builder install-app-deps"
  }
}
```

## 4. 总结

### 4.1 项目结构特点

1. **清晰的分层架构**: 主进程、渲染进程、共享代码分离
2. **模块化设计**: 功能模块独立，便于维护和测试
3. **类型安全**: 全面使用 TypeScript，确保代码质量
4. **可扩展性**: 预留扩展接口，支持功能增量开发

### 4.2 开发规范优势

1. **代码一致性**: 统一的命名、格式、注释规范
2. **质量保证**: 完整的测试体系和代码检查
3. **安全可靠**: 严格的安全规范和错误处理
4. **性能优化**: 内存管理、渲染优化、启动优化

### 4.3 最佳实践

1. **遵循单一职责原则**: 每个模块只负责一个功能
2. **依赖注入**: 降低模块间耦合度
3. **错误边界**: 完善的错误处理和恢复机制
4. **持续集成**: 自动化的构建、测试、部署流程

这套项目结构设计和开发规范为 OfferHelper 桌面端应用提供了坚实的技术基础，确保项目能够高质量、高效率地开发和维护。
