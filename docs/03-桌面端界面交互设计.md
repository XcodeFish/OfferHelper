# 桌面端界面交互设计

## 1. 设计理念

### 1.1 设计原则

- **隐蔽性优先**: 界面设计以不被发现为首要目标
- **效率至上**: 快速响应，一键操作
- **简洁明了**: 信息层次清晰，避免干扰
- **智能适应**: 根据使用场景自动调整

### 1.2 用户体验目标

- 零学习成本的直观操作
- 毫秒级的响应速度
- 无感知的隐私保护
- 专业的面试辅助效果

## 2. 界面布局设计

### 2.1 主界面结构

```
┌─────────────────────────────────────┐
│  🔵 OfferHelper              ─  ×   │ ← 标题栏 (40px)
├─────────────────────────────────────┤
│  🟢 正在监听...                      │ ← 状态栏 (50px)
├─────────────────────────────────────┤
│  📝 面试官问题                       │
│  ┌─────────────────────────────────┐ │
│  │ 请介绍一下你的项目经验...        │ │ ← 问题显示区 (100px)
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│  💡 建议回答                 置信度85% │
│  ┌─────────────────────────────────┐ │
│  │ 我在之前的工作中主要负责...      │ │
│  │                                 │ │ ← 答案显示区 (200px)
│  │ 关键词: React, Node.js, 项目管理 │ │
│  │                                 │ │
│  │ 💡 回答建议:                    │ │
│  │ • 结合具体项目案例              │ │
│  │ • 突出技术难点和解决方案        │ │
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│  [🎤 开始监听]  [👁 隐藏助手]        │ ← 控制面板 (60px)
└─────────────────────────────────────┘
总高度: 450px, 宽度: 380px
```

### 2.2 响应式布局

```css
/* 基础布局 */
.app-container {
  width: 380px;
  min-height: 450px;
  max-height: 80vh;
  background: rgba(0, 0, 0, 0.92);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(20px);
  box-shadow:
    0 20px 40px rgba(0, 0, 0, 0.4),
    0 0 0 1px rgba(255, 255, 255, 0.05);
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

/* 紧凑模式 */
.app-container.compact {
  width: 320px;
  min-height: 200px;
}

/* 展开模式 */
.app-container.expanded {
  width: 450px;
  max-height: 90vh;
}

/* 迷你模式 */
.app-container.mini {
  width: 60px;
  height: 60px;
  border-radius: 50%;
}
```

## 3. 组件设计规范

### 3.1 标题栏组件

```tsx
interface TitleBarProps {
  title: string;
  onMinimize: () => void;
  onClose: () => void;
  onDoubleClick: () => void;
}

const TitleBar: React.FC<TitleBarProps> = ({
  title,
  onMinimize,
  onClose,
  onDoubleClick
}) => {
  return (
    <div
      className="title-bar"
      onDoubleClick={onDoubleClick}
    >
      <div className="title-content">
        <div className="app-icon">🎯</div>
        <span className="app-title">{title}</span>
      </div>

      <div className="window-controls">
        <button
          className="control-btn minimize"
          onClick={onMinimize}
          title="最小化"
        >
          <MinusIcon size={12} />
        </button>
        <button
          className="control-btn close"
          onClick={onClose}
          title="隐藏"
        >
          <XIcon size={12} />
        </button>
      </div>
    </div>
  );
};
```

### 3.2 状态指示器组件

```tsx
interface StatusIndicatorProps {
  status: 'idle' | 'listening' | 'analyzing' | 'hidden';
  confidence?: number;
  isOnline: boolean;
}

const StatusIndicator: React.FC<StatusIndicatorProps> = ({
  status,
  confidence,
  isOnline
}) => {
  const getStatusConfig = () => {
    switch (status) {
      case 'listening':
        return {
          color: '#10b981',
          icon: '🎤',
          text: '正在监听...',
          animation: 'pulse'
        };
      case 'analyzing':
        return {
          color: '#f59e0b',
          icon: '🧠',
          text: 'AI分析中...',
          animation: 'spin'
        };
      case 'hidden':
        return {
          color: '#6b7280',
          icon: '👁‍🗨',
          text: '已隐藏',
          animation: 'none'
        };
      default:
        return {
          color: '#6b7280',
          icon: '⏸',
          text: '待机中',
          animation: 'none'
        };
    }
  };

  const config = getStatusConfig();

  return (
    <div className="status-indicator">
      <div className="status-main">
        <div
          className={`status-dot ${config.animation}`}
          style={{ backgroundColor: config.color }}
        >
          {config.animation === 'pulse' && <div className="pulse-ring" />}
          {config.animation === 'spin' && <div className="spin-ring" />}
        </div>

        <div className="status-info">
          <span className="status-text">{config.text}</span>
          {confidence && (
            <div className="confidence-indicator">
              <span className="confidence-text">置信度: {Math.round(confidence * 100)}%</span>
              <div className="confidence-bar">
                <div
                  className="confidence-fill"
                  style={{ width: `${confidence * 100}%` }}
                />
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="connection-status">
        <div className={`connection-dot ${isOnline ? 'online' : 'offline'}`} />
        <span className="connection-text">
          {isOnline ? '在线' : '离线'}
        </span>
      </div>
    </div>
  );
};
```

### 3.3 问题显示组件

```tsx
interface QuestionDisplayProps {
  question: string;
  isListening: boolean;
  interimResult?: string;
}

const QuestionDisplay: React.FC<QuestionDisplayProps> = ({
  question,
  isListening,
  interimResult
}) => {
  return (
    <div className="question-display">
      <div className="question-header">
        <h3>面试官问题</h3>
        <div className="question-actions">
          <button className="action-btn" title="复制问题">
            <CopyIcon size={14} />
          </button>
          <button className="action-btn" title="清除问题">
            <TrashIcon size={14} />
          </button>
        </div>
      </div>

      <div className="question-content">
        {question ? (
          <div className="question-text final">{question}</div>
        ) : isListening ? (
          <div className="question-text listening">
            {interimResult || '正在监听面试官提问...'}
            <span className="cursor-blink">|</span>
          </div>
        ) : (
          <div className="question-text placeholder">
            点击"开始监听"按钮开始识别面试官问题
          </div>
        )}
      </div>

      {isListening && (
        <div className="audio-visualizer">
          <div className="wave-bar" style={{ animationDelay: '0ms' }} />
          <div className="wave-bar" style={{ animationDelay: '100ms' }} />
          <div className="wave-bar" style={{ animationDelay: '200ms' }} />
          <div className="wave-bar" style={{ animationDelay: '300ms' }} />
          <div className="wave-bar" style={{ animationDelay: '400ms' }} />
        </div>
      )}
    </div>
  );
};
```

### 3.4 答案面板组件

```tsx
interface AnswerPanelProps {
  response: AIResponse;
  isLoading: boolean;
  onCopy: () => void;
  onRegenerate: () => void;
  onClose: () => void;
}

const AnswerPanel: React.FC<AnswerPanelProps> = ({
  response,
  isLoading,
  onCopy,
  onRegenerate,
  onClose
}) => {
  if (isLoading) {
    return (
      <div className="answer-panel loading">
        <div className="loading-header">
          <div className="loading-icon">🧠</div>
          <span>AI正在分析问题...</span>
        </div>
        <div className="loading-animation">
          <div className="loading-dots">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </div>
      </div>
    );
  }

  if (!response) return null;

  return (
    <motion.div
      className="answer-panel"
      initial={{ opacity: 0, y: 20, scale: 0.95 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, y: -20, scale: 0.95 }}
      transition={{ duration: 0.3, ease: "easeOut" }}
    >
      <div className="answer-header">
        <div className="answer-title">
          <h3>💡 建议回答</h3>
          <div className="confidence-badge">
            置信度: {Math.round(response.confidence * 100)}%
          </div>
        </div>

        <div className="answer-actions">
          <button
            className="action-btn"
            onClick={onCopy}
            title="复制回答"
          >
            <CopyIcon size={14} />
          </button>
          <button
            className="action-btn"
            onClick={onRegenerate}
            title="重新生成"
          >
            <RefreshIcon size={14} />
          </button>
          <button
            className="action-btn close"
            onClick={onClose}
            title="关闭"
          >
            <XIcon size={14} />
          </button>
        </div>
      </div>

      <div className="answer-content">
        <div className="answer-text">
          {response.answer}
        </div>

        {response.keywords.length > 0 && (
          <div className="keywords-section">
            <span className="section-label">关键词:</span>
            <div className="keywords-list">
              {response.keywords.map((keyword, index) => (
                <span key={index} className="keyword-tag">
                  {keyword}
                </span>
              ))}
            </div>
          </div>
        )}

        {response.suggestions.length > 0 && (
          <div className="suggestions-section">
            <span className="section-label">💡 回答建议:</span>
            <ul className="suggestions-list">
              {response.suggestions.map((suggestion, index) => (
                <li key={index}>{suggestion}</li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </motion.div>
  );
};
```

### 3.5 控制面板组件

```tsx
interface ControlPanelProps {
  isListening: boolean;
  isHidden: boolean;
  onToggleListening: () => void;
  onHide: () => void;
  onSettings: () => void;
  onKnowledgeBase: () => void;
}

const ControlPanel: React.FC<ControlPanelProps> = ({
  isListening,
  isHidden,
  onToggleListening,
  onHide,
  onSettings,
  onKnowledgeBase
}) => {
  return (
    <div className="control-panel">
      <div className="primary-controls">
        <button
          className={`control-btn primary ${isListening ? 'listening' : ''}`}
          onClick={onToggleListening}
        >
          <div className="btn-icon">
            {isListening ? <StopIcon size={16} /> : <MicIcon size={16} />}
          </div>
          <span>{isListening ? '停止监听' : '开始监听'}</span>
        </button>
      </div>

      <div className="secondary-controls">
        <button
          className="control-btn secondary"
          onClick={onHide}
          title="隐藏助手"
        >
          <EyeOffIcon size={16} />
        </button>

        <button
          className="control-btn secondary"
          onClick={onKnowledgeBase}
          title="知识库"
        >
          <BookIcon size={16} />
        </button>

        <button
          className="control-btn secondary"
          onClick={onSettings}
          title="设置"
        >
          <SettingsIcon size={16} />
        </button>
      </div>
    </div>
  );
};
```

## 4. 交互动画设计

### 4.1 动画配置

```css
/* 全局动画变量 */
:root {
  --animation-fast: 0.15s;
  --animation-normal: 0.3s;
  --animation-slow: 0.5s;
  --easing-smooth: cubic-bezier(0.4, 0, 0.2, 1);
  --easing-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

/* 脉冲动画 */
@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.1);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* 旋转动画 */
@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* 波浪动画 */
@keyframes wave {
  0%, 100% {
    height: 4px;
  }
  50% {
    height: 20px;
  }
}

/* 闪烁动画 */
@keyframes blink {
  0%, 50% {
    opacity: 1;
  }
  51%, 100% {
    opacity: 0;
  }
}

/* 加载点动画 */
@keyframes loading-dots {
  0%, 20% {
    opacity: 0;
    transform: scale(0.8);
  }
  50% {
    opacity: 1;
    transform: scale(1);
  }
  100% {
    opacity: 0;
    transform: scale(0.8);
  }
}
```

### 4.2 状态转换动画

```tsx
const AnimatedStatusTransition: React.FC<{
  status: string;
  children: React.ReactNode;
}> = ({ status, children }) => {
  return (
    <AnimatePresence mode="wait">
      <motion.div
        key={status}
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 1.1 }}
        transition={{
          duration: 0.2,
          ease: "easeInOut"
        }}
      >
        {children}
      </motion.div>
    </AnimatePresence>
  );
};
```

### 4.3 手势交互

```tsx
const GestureHandler: React.FC<{
  onSwipeUp: () => void;
  onSwipeDown: () => void;
  onDoubleClick: () => void;
  children: React.ReactNode;
}> = ({ onSwipeUp, onSwipeDown, onDoubleClick, children }) => {
  const [startY, setStartY] = useState(0);
  const [lastClickTime, setLastClickTime] = useState(0);

  const handleTouchStart = (e: React.TouchEvent) => {
    setStartY(e.touches[0].clientY);
  };

  const handleTouchEnd = (e: React.TouchEvent) => {
    const endY = e.changedTouches[0].clientY;
    const deltaY = startY - endY;

    if (Math.abs(deltaY) > 50) {
      if (deltaY > 0) {
        onSwipeUp();
      } else {
        onSwipeDown();
      }
    }
  };

  const handleClick = () => {
    const now = Date.now();
    if (now - lastClickTime < 300) {
      onDoubleClick();
    }
    setLastClickTime(now);
  };

  return (
    <div
      onTouchStart={handleTouchStart}
      onTouchEnd={handleTouchEnd}
      onClick={handleClick}
    >
      {children}
    </div>
  );
};
```

## 5. 主题系统

### 5.1 主题定义

```typescript
interface Theme {
  name: string;
  colors: {
    primary: string;
    secondary: string;
    background: string;
    surface: string;
    text: {
      primary: string;
      secondary: string;
      disabled: string;
    };
    status: {
      success: string;
      warning: string;
      error: string;
      info: string;
    };
    border: string;
    shadow: string;
  };
  typography: {
    fontFamily: string;
    fontSize: {
      xs: string;
      sm: string;
      md: string;
      lg: string;
      xl: string;
    };
    fontWeight: {
      normal: number;
      medium: number;
      bold: number;
    };
  };
  spacing: {
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
  };
  borderRadius: {
    sm: string;
    md: string;
    lg: string;
    full: string;
  };
}

const darkTheme: Theme = {
  name: 'dark',
  colors: {
    primary: '#667eea',
    secondary: '#764ba2',
    background: 'rgba(0, 0, 0, 0.92)',
    surface: 'rgba(255, 255, 255, 0.05)',
    text: {
      primary: '#f3f4f6',
      secondary: '#d1d5db',
      disabled: '#6b7280'
    },
    status: {
      success: '#10b981',
      warning: '#f59e0b',
      error: '#ef4444',
      info: '#3b82f6'
    },
    border: 'rgba(255, 255, 255, 0.1)',
    shadow: 'rgba(0, 0, 0, 0.4)'
  },
  typography: {
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
    fontSize: {
      xs: '11px',
      sm: '12px',
      md: '14px',
      lg: '16px',
      xl: '18px'
    },
    fontWeight: {
      normal: 400,
      medium: 500,
      bold: 600
    }
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '12px',
    lg: '16px',
    xl: '20px'
  },
  borderRadius: {
    sm: '4px',
    md: '8px',
    lg: '12px',
    full: '50%'
  }
};

const lightTheme: Theme = {
  ...darkTheme,
  name: 'light',
  colors: {
    ...darkTheme.colors,
    background: 'rgba(255, 255, 255, 0.95)',
    surface: 'rgba(0, 0, 0, 0.05)',
    text: {
      primary: '#1f2937',
      secondary: '#4b5563',
      disabled: '#9ca3af'
    },
    border: 'rgba(0, 0, 0, 0.1)',
    shadow: 'rgba(0, 0, 0, 0.1)'
  }
};
```

### 5.2 主题提供者

```tsx
const ThemeContext = React.createContext<{
  theme: Theme;
  toggleTheme: () => void;
}>({
  theme: darkTheme,
  toggleTheme: () => {}
});

export const ThemeProvider: React.FC<{
  children: React.ReactNode;
}> = ({ children }) => {
  const [currentTheme, setCurrentTheme] = useState<Theme>(darkTheme);

  const toggleTheme = () => {
    setCurrentTheme(prev =>
      prev.name === 'dark' ? lightTheme : darkTheme
    );
  };

  useEffect(() => {
    // 应用CSS变量
    const root = document.documentElement;
    Object.entries(currentTheme.colors).forEach(([key, value]) => {
      if (typeof value === 'string') {
        root.style.setProperty(`--color-${key}`, value);
      } else {
        Object.entries(value).forEach(([subKey, subValue]) => {
          root.style.setProperty(`--color-${key}-${subKey}`, subValue);
        });
      }
    });
  }, [currentTheme]);

  return (
    <ThemeContext.Provider value={{ theme: currentTheme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => useContext(ThemeContext);
```

## 6. 响应式设计

### 6.1 断点系统

```css
/* 响应式断点 */
:root {
  --breakpoint-sm: 320px;
  --breakpoint-md: 380px;
  --breakpoint-lg: 450px;
}

/* 小屏幕适配 */
@media (max-width: 320px) {
  .app-container {
    width: 100vw;
    height: 100vh;
    border-radius: 0;
  }

  .question-display,
  .answer-panel {
    font-size: 12px;
    padding: 12px;
  }

  .control-panel {
    flex-direction: column;
    gap: 8px;
  }
}

/* 中等屏幕适配 */
@media (min-width: 321px) and (max-width: 450px) {
  .app-container {
    width: 90vw;
    max-width: 380px;
  }
}

/* 大屏幕适配 */
@media (min-width: 451px) {
  .app-container {
    width: 450px;
  }

  .answer-panel {
    max-height: 400px;
  }
}
```

### 6.2 自适应布局

```tsx
const ResponsiveLayout: React.FC<{
  children: React.ReactNode;
}> = ({ children }) => {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const getLayoutClass = () => {
    if (windowSize.width < 321) return 'layout-sm';
    if (windowSize.width < 451) return 'layout-md';
    return 'layout-lg';
  };

  return (
    <div className={`responsive-layout ${getLayoutClass()}`}>
      {children}
    </div>
  );
};
```

## 7. 无障碍设计

### 7.1 键盘导航

```tsx
const KeyboardNavigation: React.FC = () => {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Tab 键导航
      if (e.key === 'Tab') {
        const focusableElements = document.querySelectorAll(
          'button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );

        const firstElement = focusableElements[0] as HTMLElement;
        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

        if (e.shiftKey && document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }

      // 快捷键
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 'h':
            e.preventDefault();
            // 隐藏/显示窗口
            break;
          case 'l':
            e.preventDefault();
            // 开始/停止监听
            break;
          case 'c':
            e.preventDefault();
            // 复制回答
            break;
        }
      }

      // ESC 键关闭面板
      if (e.key === 'Escape') {
        // 关闭当前打开的面板
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  return null;
};
```

### 7.2 屏幕阅读器支持

```tsx
const AccessibleButton: React.FC<{
  children: React.ReactNode;
  onClick: () => void;
  ariaLabel: string;
  disabled?: boolean;
}> = ({ children, onClick, ariaLabel, disabled = false }) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      aria-label={ariaLabel}
      aria-disabled={disabled}
      role="button"
      tabIndex={disabled ? -1 : 0}
    >
      {children}
    </button>
  );
};

const AccessibleStatus: React.FC<{
  status: string;
  isLive?: boolean;
}> = ({ status, isLive = true }) => {
  return (
    <div
      role="status"
      aria-live={isLive ? "polite" : "off"}
      aria-atomic="true"
    >
      {status}
    </div>
  );
};
```

## 8. 性能优化

### 8.1 组件懒加载

```tsx
const LazyAnswerPanel = React.lazy(() => import('./AnswerPanel'));
const LazySettingsPanel = React.lazy(() => import('./SettingsPanel'));
const LazyKnowledgeBase = React.lazy(() => import('./KnowledgeBase'));

const App: React.FC = () => {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Router>
        <Routes>
          <Route path="/" element={<MainPanel />} />
          <Route path="/settings" element={<LazySettingsPanel />} />
          <Route path="/knowledge" element={<LazyKnowledgeBase />} />
        </Routes>
      </Router>
    </Suspense>
  );
};
```

### 8.2 虚拟化长列表

```tsx
const VirtualizedKnowledgeList: React.FC<{
  items: KnowledgeItem[];
}> = ({ items }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 10 });

  const itemHeight = 60;
  const containerHeight = 300;

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => {
      const scrollTop = container.scrollTop;
      const start = Math.floor(scrollTop / itemHeight);
      const end = Math.min(
        start + Math.ceil(containerHeight / itemHeight) + 2,
        items.length
      );

      setVisibleRange({ start, end });
    };

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [items.length]);

  const visibleItems = items.slice(visibleRange.start, visibleRange.end);
  const totalHeight = items.length * itemHeight;
  const offsetY = visibleRange.start * itemHeight;

  return (
    <div
      ref={containerRef}
      className="virtualized-list"
      style={{ height: containerHeight, overflow: 'auto' }}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <KnowledgeItem
              key={item.id}
              item={item}
              style={{ height: itemHeight }}
            />
          ))}
        </div>
      </div>
    </div>
  );
};
```

## 9. 样式系统

### 9.1 完整样式定义

```css
/* 全局样式重置 */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: var(--font-family);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* 应用容器 */
.app-container {
  width: 380px;
  min-height: 450px;
  background: var(--color-background);
  border-radius: var(--border-radius-lg);
  border: 1px solid var(--color-border);
  backdrop-filter: blur(20px);
  box-shadow:
    0 20px 40px var(--color-shadow),
    0 0 0 1px rgba(255, 255, 255, 0.05);
  overflow: hidden;
  font-family: var(--font-family);
  user-select: none;
  -webkit-user-select: none;
}

/* 标题栏 */
.title-bar {
  -webkit-app-region: drag;
  height: 40px;
  background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 var(--spacing-lg);
  color: white;
}

.title-content {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.app-icon {
  font-size: 16px;
}

.app-title {
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-medium);
}

.window-controls {
  -webkit-app-region: no-drag;
  display: flex;
  gap: var(--spacing-sm);
}

.control-btn {
  width: 20px;
  height: 20px;
  border-radius: var(--border-radius-full);
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--animation-fast) var(--easing-smooth);
  background: rgba(255, 255, 255, 0.2);
  color: white;
}

.control-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.1);
}

.control-btn.minimize {
  background: #ffbd2e;
}

.control-btn.close {
  background: #ff5f57;
}

/* 内容区域 */
.content-area {
  padding: var(--spacing-lg);
  height: calc(100% - 40px);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-lg);
}

/* 状态指示器 */
.status-indicator {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-md);
  background: var(--color-surface);
  border-radius: var(--border-radius-md);
  border: 1px solid var(--color-border);
}

.status-main {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.status-dot {
  position: relative;
  width: 12px;
  height: 12px;
  border-radius: var(--border-radius-full);
  transition: all var(--animation-normal) var(--easing-smooth);
}

.status-dot.pulse {
  animation: pulse 2s infinite;
}

.status-dot.spin {
  animation: spin 1s linear infinite;
}

.pulse-ring {
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border-radius: var(--border-radius-full);
  background: currentColor;
  opacity: 0.3;
  animation: pulse 2s infinite;
}

.status-info {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.status-text {
  color: var(--color-text-primary);
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-medium);
}

.confidence-indicator {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-xs);
}

.confidence-text {
  color: var(--color-text-secondary);
  font-size: var(--font-size-sm);
}

.confidence-bar {
  width: 60px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: var(--border-radius-sm);
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--color-status-success), var(--color-status-warning));
  transition: width var(--animation-normal) var(--easing-smooth);
}

.connection-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.connection-dot {
  width: 8px;
  height: 8px;
  border-radius: var(--border-radius-full);
  background: var(--color-status-error);
  transition: all var(--animation-fast) var(--easing-smooth);
}

.connection-dot.online {
  background: var(--color-status-success);
}

.connection-text {
  color: var(--color-text-secondary);
  font-size: var(--font-size-xs);
}

/* 问题显示区域 */
.question-display {
  background: var(--color-surface);
  border-radius: var(--border-radius-md);
  border: 1px solid var(--color-border);
  border-left: 4px solid var(--color-primary);
  overflow: hidden;
}

.question-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-md) var(--spacing-lg);
  background: rgba(255, 255, 255, 0.02);
  border-bottom: 1px solid var(--color-border);
}

.question-header h3 {
  color: var(--color-text-primary);
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-medium);
  margin: 0;
}

.question-actions {
  display: flex;
  gap: var(--spacing-xs);
}

.action-btn {
  width: 24px;
  height: 24px;
  border: none;
  background: rgba(255, 255, 255, 0.1);
  color: var(--color-text-secondary);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--animation-fast) var(--easing-smooth);
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  color: var(--color-text-primary);
  transform: scale(1.1);
}

.question-content {
  padding: var(--spacing-lg);
  min-height: 60px;
  display: flex;
  align-items: center;
}

.question-text {
  color: var(--color-text-primary);
  font-size: var(--font-size-md);
  line-height: 1.5;
  width: 100%;
}

.question-text.listening {
  color: var(--color-status-info);
  font-style: italic;
}

.question-text.placeholder {
  color: var(--color-text-disabled);
  text-align: center;
}

.cursor-blink {
  animation: blink 1s infinite;
  color: var(--color-primary);
}

.audio-visualizer {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2px;
  margin-top: var(--spacing-md);
  height: 24px;
}

.wave-bar {
  width: 3px;
  height: 4px;
  background: var(--color-primary);
  border-radius: var(--border-radius-sm);
  animation: wave 1.5s ease-in-out infinite;
}

/* 答案面板 */
.answer-panel {
  background: var(--color-surface);
  border-radius: var(--border-radius-lg);
  border: 1px solid var(--color-border);
  overflow: hidden;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
}

.answer-panel.loading {
  padding: var(--spacing-xl);
  text-align: center;
}

.loading-header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.loading-icon {
  font-size: 24px;
  animation: spin 2s linear infinite;
}

.loading-animation {
  display: flex;
  justify-content: center;
}

.loading-dots {
  display: flex;
  gap: var(--spacing-xs);
}

.loading-dots span {
  width: 8px;
  height: 8px;
  background: var(--color-primary);
  border-radius: var(--border-radius-full);
  animation: loading-dots 1.4s ease-in-out infinite both;
}

.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }
.loading-dots span:nth-child(3) { animation-delay: 0s; }

.answer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-lg);
  background: rgba(255, 255, 255, 0.02);
  border-bottom: 1px solid var(--color-border);
}

.answer-title {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.answer-title h3 {
  color: var(--color-text-primary);
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-medium);
  margin: 0;
}

.confidence-badge {
  background: linear-gradient(135deg, var(--color-status-success), var(--color-status-warning));
  color: white;
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-medium);
}

.answer-actions {
  display: flex;
  gap: var(--spacing-xs);
}

.answer-content {
  padding: var(--spacing-lg);
}

.answer-text {
  color: var(--color-text-primary);
  font-size: var(--font-size-md);
  line-height: 1.6;
  margin-bottom: var(--spacing-lg);
  padding: var(--spacing-md);
  background: rgba(0, 0, 0, 0.2);
  border-radius: var(--border-radius-md);
  border-left: 3px solid var(--color-primary);
}

.keywords-section,
.suggestions-section {
  margin-bottom: var(--spacing-lg);
}

.keywords-section:last-child,
.suggestions-section:last-child {
  margin-bottom: 0;
}

.section-label {
  color: var(--color-text-secondary);
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  display: block;
  margin-bottom: var(--spacing-sm);
}

.keywords-list {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-xs);
}

.keyword-tag {
  background: rgba(102, 126, 234, 0.2);
  color: var(--color-primary);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-medium);
  border: 1px solid rgba(102, 126, 234, 0.3);
}

.suggestions-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.suggestions-list li {
  color: var(--color-text-secondary);
  font-size: var(--font-size-sm);
  line-height: 1.5;
  margin-bottom: var(--spacing-sm);
  padding-left: var(--spacing-lg);
  position: relative;
}

.suggestions-list li:before {
  content: "•";
  color: var(--color-primary);
  position: absolute;
  left: 0;
  font-weight: bold;
}

.suggestions-list li:last-child {
  margin-bottom: 0;
}

/* 控制面板 */
.control-panel {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  margin-top: auto;
}

.primary-controls {
  display: flex;
}

.secondary-controls {
  display: flex;
  gap: var(--spacing-sm);
  justify-content: center;
}

.control-btn.primary {
  flex: 1;
  height: 48px;
  background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
  color: white;
  border: none;
  border-radius: var(--border-radius-md);
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-medium);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-sm);
  transition: all var(--animation-normal) var(--easing-smooth);
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.control-btn.primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
}

.control-btn.primary:active {
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

.control-btn.primary.listening {
  background: linear-gradient(135deg, var(--color-status-error), #dc2626);
}

.control-btn.primary.listening:hover {
  box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
}

.btn-icon {
  display: flex;
  align-items: center;
  justify-content: center;
}

.control-btn.secondary {
  width: 40px;
  height: 40px;
  background: var(--color-surface);
  color: var(--color-text-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-md);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--animation-fast) var(--easing-smooth);
}

.control-btn.secondary:hover {
  background: rgba(255, 255, 255, 0.1);
  color: var(--color-text-primary);
  border-color: var(--color-primary);
  transform: scale(1.05);
}

/* 滚动条样式 */
.content-area::-webkit-scrollbar {
  width: 6px;
}

.content-area::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: var(--border-radius-sm);
}

.content-area::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: var(--border-radius-sm);
}

.content-area::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* 工具提示 */
.tooltip {
  position: relative;
}

.tooltip:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-xs);
  white-space: nowrap;
  z-index: 1000;
  margin-bottom: var(--spacing-xs);
}

.tooltip:hover::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 4px solid transparent;
  border-top-color: rgba(0, 0, 0, 0.9);
  z-index: 1000;
}

/* 响应式调整 */
@media (max-width: 320px) {
  .answer-text {
    font-size: var(--font-size-sm);
    padding: var(--spacing-sm);
  }

  .control-btn.primary {
    height: 40px;
    font-size: var(--font-size-sm);
  }

  .keywords-list {
    gap: var(--spacing-xs);
  }

  .keyword-tag {
    font-size: 10px;
    padding: 2px var(--spacing-xs);
  }
}

/* 暗色主题特定样式 */
[data-theme="dark"] {
  --color-background: rgba(0, 0, 0, 0.95);
  --color-surface: rgba(255, 255, 255, 0.05);
  --color-border: rgba(255, 255, 255, 0.1);
}

/* 亮色主题特定样式 */
[data-theme="light"] {
  --color-background: rgba(255, 255, 255, 0.95);
  --color-surface: rgba(0, 0, 0, 0.05);
  --color-border: rgba(0, 0, 0, 0.1);
}

/* 高对比度模式 */
@media (prefers-contrast: high) {
  .app-container {
    border: 2px solid var(--color-primary);
  }

  .control-btn {
    border: 1px solid currentColor;
  }

  .question-text,
  .answer-text {
    font-weight: var(--font-weight-medium);
  }
}

/* 减少动画模式 */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }

  .pulse-ring,
  .wave-bar,
  .loading-dots span {
    animation: none;
  }
}

/* 打印样式 */
@media print {
  .app-container {
    background: white;
    color: black;
    box-shadow: none;
    border: 1px solid black;
  }

  .title-bar,
  .control-panel {
    display: none;
  }

  .answer-text {
    background: none;
    border: 1px solid black;
  }
}
```

## 10. 交互状态管理

### 10.1 状态定义

```typescript
interface AppState {
  ui: {
    isVisible: boolean;
    isMinimized: boolean;
    currentView: 'main' | 'settings' | 'knowledge';
    theme: 'dark' | 'light';
    opacity: number;
    position: { x: number; y: number };
  };
  speech: {
    isListening: boolean;
    currentQuestion: string;
    interimResult: string;
    isProcessing: boolean;
  };
  ai: {
    isAnalyzing: boolean;
    currentResponse: AIResponse | null;
    history: Array<{
      question: string;
      response: AIResponse;
      timestamp: Date;
    }>;
  };
  privacy: {
    isHidden: boolean;
    screenSharingDetected: boolean;
    autoHideEnabled: boolean;
  };
  system: {
    isOnline: boolean;
    lastError: string | null;
    performance: {
      memoryUsage: number;
      cpuUsage: number;
    };
  };
}
```

### 10.2 状态管理器

```typescript
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface AppStore extends AppState {
  // UI Actions
  setVisible: (visible: boolean) => void;
  setMinimized: (minimized: boolean) => void;
  setCurrentView: (view: AppState['ui']['currentView']) => void;
  setTheme: (theme: AppState['ui']['theme']) => void;
  setOpacity: (opacity: number) => void;
  setPosition: (position: { x: number; y: number }) => void;

  // Speech Actions
  startListening: () => void;
  stopListening: () => void;
  setCurrentQuestion: (question: string) => void;
  setInterimResult: (result: string) => void;
  setProcessing: (processing: boolean) => void;

  // AI Actions
  setAnalyzing: (analyzing: boolean) => void;
  setCurrentResponse: (response: AIResponse | null) => void;
  addToHistory: (question: string, response: AIResponse) => void;
  clearHistory: () => void;

  // Privacy Actions
  setHidden: (hidden: boolean) => void;
  setScreenSharingDetected: (detected: boolean) => void;
  setAutoHideEnabled: (enabled: boolean) => void;

  // System Actions
  setOnline: (online: boolean) => void;
  setLastError: (error: string | null) => void;
  updatePerformance: (performance: Partial<AppState['system']['performance']>) => void;
}

export const useAppStore = create<AppStore>()(
  subscribeWithSelector((set, get) => ({
    // Initial State
    ui: {
      isVisible: true,
      isMinimized: false,
      currentView: 'main',
      theme: 'dark',
      opacity: 0.9,
      position: { x: 100, y: 100 }
    },
    speech: {
      isListening: false,
      currentQuestion: '',
      interimResult: '',
      isProcessing: false
    },
    ai: {
      isAnalyzing: false,
      currentResponse: null,
      history: []
    },
    privacy: {
      isHidden: false,
      screenSharingDetected: false,
      autoHideEnabled: true
    },
    system: {
      isOnline: true,
      lastError: null,
      performance: {
        memoryUsage: 0,
        cpuUsage: 0
      }
    },

    // UI Actions
    setVisible: (visible) => set((state) => ({
      ui: { ...state.ui, isVisible: visible }
    })),

    setMinimized: (minimized) => set((state) => ({
      ui: { ...state.ui, isMinimized: minimized }
    })),

    setCurrentView: (view) => set((state) => ({
      ui: { ...state.ui, currentView: view }
    })),

    setTheme: (theme) => set((state) => ({
      ui: { ...state.ui, theme }
    })),

    setOpacity: (opacity) => set((state) => ({
      ui: { ...state.ui, opacity }
    })),

    setPosition: (position) => set((state) => ({
      ui: { ...state.ui, position }
    })),

    // Speech Actions
    startListening: () => set((state) => ({
      speech: { ...state.speech, isListening: true }
    })),

    stopListening: () => set((state) => ({
      speech: { ...state.speech, isListening: false, interimResult: '' }
    })),

    setCurrentQuestion: (currentQuestion) => set((state) => ({
      speech: { ...state.speech, currentQuestion }
    })),

    setInterimResult: (interimResult) => set((state) => ({
      speech: { ...state.speech, interimResult }
    })),

    setProcessing: (isProcessing) => set((state) => ({
      speech: { ...state.speech, isProcessing }
    })),

    // AI Actions
    setAnalyzing: (isAnalyzing) => set((state) => ({
      ai: { ...state.ai, isAnalyzing }
    })),

    setCurrentResponse: (currentResponse) => set((state) => ({
      ai: { ...state.ai, currentResponse }
    })),

    addToHistory: (question, response) => set((state) => ({
      ai: {
        ...state.ai,
        history: [
          ...state.ai.history,
          { question, response, timestamp: new Date() }
        ].slice(-50) // 保留最近50条记录
      }
    })),

    clearHistory: () => set((state) => ({
      ai: { ...state.ai, history: [] }
    })),

    // Privacy Actions
    setHidden: (isHidden) => set((state) => ({
      privacy: { ...state.privacy, isHidden }
    })),

    setScreenSharingDetected: (screenSharingDetected) => set((state) => ({
      privacy: { ...state.privacy, screenSharingDetected }
    })),

    setAutoHideEnabled: (autoHideEnabled) => set((state) => ({
      privacy: { ...state.privacy, autoHideEnabled }
    })),

    // System Actions
    setOnline: (isOnline) => set((state) => ({
      system: { ...state.system, isOnline }
    })),

    setLastError: (lastError) => set((state) => ({
      system: { ...state.system, lastError }
    })),

    updatePerformance: (performance) => set((state) => ({
      system: {
        ...state.system,
        performance: { ...state.system.performance, ...performance }
      }
    }))
  }))
);

// 状态订阅器
export const useAppSubscriptions = () => {
  useEffect(() => {
    // 监听隐私状态变化
    const unsubscribePrivacy = useAppStore.subscribe(
      (state) => state.privacy.screenSharingDetected,
      (detected) => {
        if (detected && useAppStore.getState().privacy.autoHideEnabled) {
          useAppStore.getState().setHidden(true);
        }
      }
    );

    // 监听主题变化
    const unsubscribeTheme = useAppStore.subscribe(
      (state) => state.ui.theme,
      (theme) => {
        document.documentElement.setAttribute('data-theme', theme);
      }
    );

    // 监听错误状态
    const unsubscribeError = useAppStore.subscribe(
      (state) => state.system.lastError,
      (error) => {
        if (error) {
          console.error('应用错误:', error);
          // 可以在这里添加错误通知逻辑
        }
      }
    );

    return () => {
      unsubscribePrivacy();
      unsubscribeTheme();
      unsubscribeError();
    };
  }, []);
};
```

## 11. 总结

本桌面端界面交互设计文档详细描述了 OfferHelper 桌面端应用的完整界面设计方案，包括：

### 11.1 设计特色
- **隐蔽性设计**: 专为面试场景优化的低调界面
- **高效交互**: 一键操作，快速响应的用户体验
- **智能适应**: 根据使用场景自动调整界面状态
- **无障碍支持**: 完整的键盘导航和屏幕阅读器支持

### 11.2 技术实现
- **React + TypeScript**: 类型安全的组件开发
- **Framer Motion**: 流畅的动画效果
- **Zustand**: 轻量级状态管理
- **CSS Variables**: 灵活的主题系统

### 11.3 用户体验
- **零学习成本**: 直观的界面设计
- **毫秒级响应**: 优化的性能表现
- **多主题支持**: 适应不同使用环境
- **响应式布局**: 适配各种屏幕尺寸

该界面设计确保了桌面端应用在提供专业面试辅助功能的同时，保持最佳的用户体验和隐私保护效果。
# 桌面端界面交互设计

## 1. 设计理念

### 1.1 设计原则

- **隐蔽性优先**: 界面设计以不被发现为首要目标
- **效率至上**: 快速响应，一键操作
- **简洁明了**: 信息层次清晰，避免干扰
- **智能适应**: 根据使用场景自动调整

### 1.2 用户体验目标

- 零学习成本的直观操作
- 毫秒级的响应速度
- 无感知的隐私保护
- 专业的面试辅助效果

## 2. 界面布局设计

### 2.1 主界面结构

```
┌─────────────────────────────────────┐
│  🔵 OfferHelper              ─  ×   │ ← 标题栏 (40px)
├─────────────────────────────────────┤
│  🟢 正在监听...                      │ ← 状态栏 (50px)
├─────────────────────────────────────┤
│  📝 面试官问题                       │
│  ┌─────────────────────────────────┐ │
│  │ 请介绍一下你的项目经验...        │ │ ← 问题显示区 (100px)
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│  💡 建议回答                 置信度85% │
│  ┌─────────────────────────────────┐ │
│  │ 我在之前的工作中主要负责...      │ │
│  │                                 │ │ ← 答案显示区 (200px)
│  │ 关键词: React, Node.js, 项目管理 │ │
│  │                                 │ │
│  │ 💡 回答建议:                    │ │
│  │ • 结合具体项目案例              │ │
│  │ • 突出技术难点和解决方案        │ │
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│  [🎤 开始监听]  [👁 隐藏助手]        │ ← 控制面板 (60px)
└─────────────────────────────────────┘
总高度: 450px, 宽度: 380px
```

### 2.2 响应式布局

```css
/* 基础布局 */
.app-container {
  width: 380px;
  min-height: 450px;
  max-height: 80vh;
  background: rgba(0, 0, 0, 0.92);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(20px);
  box-shadow:
    0 20px 40px rgba(0, 0, 0, 0.4),
    0 0 0 1px rgba(255, 255, 255, 0.05);
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

/* 紧凑模式 */
.app-container.compact {
  width: 320px;
  min-height: 200px;
}

/* 展开模式 */
.app-container.expanded {
  width: 450px;
  max-height: 90vh;
}

/* 迷你模式 */
.app-container.mini {
  width: 60px;
  height: 60px;
  border-radius: 50%;
}
```

## 3. 组件设计规范

### 3.1 标题栏组件

```tsx
interface TitleBarProps {
  title: string;
  onMinimize: () => void;
  onClose: () => void;
  onDoubleClick: () => void;
}

const TitleBar: React.FC<TitleBarProps> = ({
  title,
  onMinimize,
  onClose,
  onDoubleClick
}) => {
  return (
    <div
      className="title-bar"
      onDoubleClick={onDoubleClick}
    >
      <div className="title-content">
        <div className="app-icon">🎯</div>
        <span className="app-title">{title}</span>
      </div>

      <div className="window-controls">
        <button
          className="control-btn minimize"
          onClick={onMinimize}
          title="最小化"
        >
          <MinusIcon size={12} />
        </button>
        <button
          className="control-btn close"
          onClick={onClose}
          title="隐藏"
        >
          <XIcon size={12} />
        </button>
      </div>
    </div>
  );
};
```

### 3.2 状态指示器组件

```tsx
interface StatusIndicatorProps {
  status: 'idle' | 'listening' | 'analyzing' | 'hidden';
  confidence?: number;
  isOnline: boolean;
}

const StatusIndicator: React.FC<StatusIndicatorProps> = ({
  status,
  confidence,
  isOnline
}) => {
  const getStatusConfig = () => {
    switch (status) {
      case 'listening':
        return {
          color: '#10b981',
          icon: '🎤',
          text: '正在监听...',
          animation: 'pulse'
        };
      case 'analyzing':
        return {
          color: '#f
