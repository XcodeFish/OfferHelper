# 腾讯云实时语音识别接口文档

## 1. 服务概述

腾讯云实时语音识别（Automatic Speech Recognition, ASR）基于深度学习技术，为开发者提供一体化的语音识别解决方案。支持实时流式识别，适合AI面试助手等实时交互场景。

### 1.1 核心优势

- **低延迟**：流式识别延迟低至200ms
- **高准确率**：中文识别准确率达95%以上
- **专业词汇**：支持自定义热词，优化程序员专业术语识别
- **多语言**：支持中英文混合识别
- **实时返回**：支持边说边识别，实时返回结果

### 1.2 适用场景

- 实时语音转文字
- 语音助手交互
- 会议记录转写
- 面试辅助工具

## 2. 接入准备

### 2.1 开通服务

1. 登录 [腾讯云控制台](https://console.cloud.tencent.com/)
2. 开通语音识别服务
3. 获取 SecretId 和 SecretKey
4. 创建应用并获取 AppId

### 2.2 环境配置

```bash
# 安装依赖
npm install tencentcloud-sdk-nodejs crypto-js ws
```

### 2.3 密钥配置

```typescript
// 配置信息
interface TencentASRConfig {
  secretId: string;        // 腾讯云 SecretId
  secretKey: string;       // 腾讯云 SecretKey
  appId: number;          // 应用 ID
  region: string;         // 地域，如 'ap-beijing'
  engineType: string;     // 引擎类型，推荐 '16k_zh'
}

// 环境变量配置
const config: TencentASRConfig = {
  secretId: process.env.TENCENT_SECRET_ID!,
  secretKey: process.env.TENCENT_SECRET_KEY!,
  appId: parseInt(process.env.TENCENT_APP_ID!),
  region: 'ap-beijing',
  engineType: '16k_zh'
};
```

## 3. WebSocket 实时识别

### 3.1 连接地址

```
wss://asr.tencentcloudapi.com/
```

### 3.2 鉴权参数

实时语音识别使用 WebSocket 协议，需要在连接时进行鉴权：

```typescript
interface AuthParams {
  secretid: string;           // 腾讯云 SecretId
  timestamp: number;          // 当前时间戳
  expired: number;           // 过期时间戳
  nonce: number;             // 随机数
  signature: string;         // 签名
  engine_model_type: string; // 引擎类型
  voice_id: string;          // 音频唯一标识
  voice_format: number;      // 音频格式：1-pcm，4-speex，6-silk，8-mp3，12-opus，14-wav
  hotword_id?: string;       // 热词 ID（可选）
  customization_id?: string; // 自学习模型 ID（可选）
  filter_dirty?: number;     // 是否过滤脏词：0-不过滤，1-过滤，2-替换为*
  filter_modal?: number;     // 是否过滤语气词：0-不过滤，1-过滤
  filter_punc?: number;      // 是否过滤标点符号：0-不过滤，1-过滤
  convert_num_mode?: number; // 数字转换模式：1-根据场景智能转换
  word_info?: number;        // 是否显示词级别时间戳：0-不显示，1-显示
}
```

### 3.3 签名算法

```typescript
import * as crypto from 'crypto';

export class TencentASRAuth {
  static generateSignature(
    secretKey: string,
    params: Record<string, any>
  ): string {
    // 1. 参数排序
    const sortedParams = Object.keys(params)
      .sort()
      .map(key => `${key}=${params[key]}`)
      .join('&');

    // 2. 构造签名原文
    const signStr = `asr.tencentcloudapi.com/asr/v2/${secretKey}?${sortedParams}`;

    // 3. 生成签名
    return crypto
      .createHash('sha1')
      .update(signStr)
      .digest('base64');
  }

  static buildAuthParams(config: TencentASRConfig): AuthParams {
    const timestamp = Math.floor(Date.now() / 1000);
    const nonce = Math.floor(Math.random() * 1000000);
    const expired = timestamp + 3600; // 1小时后过期

    const params = {
      secretid: config.secretId,
      timestamp,
      expired,
      nonce,
      engine_model_type: config.engineType,
      voice_id: `voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      voice_format: 1, // PCM格式
      filter_dirty: 1, // 过滤脏词
      filter_modal: 1, // 过滤语气词
      filter_punc: 0,  // 保留标点符号
      convert_num_mode: 1, // 智能数字转换
      word_info: 1     // 显示词级别时间戳
    };

    const signature = this.generateSignature(config.secretKey, params);

    return {
      ...params,
      signature
    };
  }
}
```

## 4. 程序员热词库配置

### 4.1 热词列表

```typescript
// 程序员专业词汇热词库
export const PROGRAMMER_HOT_WORDS = {
  // 编程语言 (权重: 10-高频使用)
  languages: [
    { word: 'JavaScript', weight: 10 },
    { word: 'TypeScript', weight: 10 },
    { word: 'Python', weight: 10 },
    { word: 'Java', weight: 10 },
    { word: 'C++', weight: 8 },
    { word: 'C#', weight: 8 },
    { word: 'Go', weight: 8 },
    { word: 'Rust', weight: 6 },
    { word: 'Swift', weight: 6 },
    { word: 'Kotlin', weight: 6 }
  ],

  // 前端框架 (权重: 9-高频)
  frontend: [
    { word: 'React', weight: 10 },
    { word: 'Vue', weight: 10 },
    { word: 'Angular', weight: 8 },
    { word: 'Next.js', weight: 8 },
    { word: 'Nuxt.js', weight: 7 },
    { word: 'Svelte', weight: 6 },
    { word: 'Webpack', weight: 8 },
    { word: 'Vite', weight: 8 },
    { word: 'Babel', weight: 7 }
  ],

  // 后端框架 (权重: 8-中高频)
  backend: [
    { word: 'Spring Boot', weight: 9 },
    { word: 'Express', weight: 8 },
    { word: 'Koa', weight: 7 },
    { word: 'Django', weight: 8 },
    { word: 'Flask', weight: 7 },
    { word: 'FastAPI', weight: 7 },
    { word: 'Gin', weight: 6 },
    { word: 'Echo', weight: 5 }
  ],

  // 数据库 (权重: 9-高频)
  database: [
    { word: 'MySQL', weight: 10 },
    { word: 'PostgreSQL', weight: 8 },
    { word: 'MongoDB', weight: 9 },
    { word: 'Redis', weight: 9 },
    { word: 'Elasticsearch', weight: 7 },
    { word: 'ClickHouse', weight: 6 },
    { word: 'SQLite', weight: 6 }
  ],

  // 云服务 (权重: 8-中高频)
  cloud: [
    { word: 'AWS', weight: 9 },
    { word: 'Azure', weight: 8 },
    { word: 'Google Cloud', weight: 8 },
    { word: '阿里云', weight: 9 },
    { word: '腾讯云', weight: 8 },
    { word: 'Docker', weight: 10 },
    { word: 'Kubernetes', weight: 9 },
    { word: 'K8s', weight: 9 }
  ],

  // 开发工具 (权重: 8-中高频)
  tools: [
    { word: 'Git', weight: 10 },
    { word: 'GitHub', weight: 9 },
    { word: 'GitLab', weight: 8 },
    { word: 'Jenkins', weight: 8 },
    { word: 'CI/CD', weight: 8 },
    { word: 'VS Code', weight: 9 },
    { word: 'IntelliJ', weight: 7 },
    { word: 'WebStorm', weight: 7 }
  ],

  // 技术概念 (权重: 9-高频)
  concepts: [
    { word: 'API', weight: 10 },
    { word: 'RESTful', weight: 9 },
    { word: 'GraphQL', weight: 8 },
    { word: '微服务', weight: 9 },
    { word: '容器化', weight: 8 },
    { word: '负载均衡', weight: 7 },
    { word: '缓存', weight: 9 },
    { word: '消息队列', weight: 8 },
    { word: 'MQ', weight: 8 },
    { word: 'RPC', weight: 7 }
  ],

  // 设计模式 (权重: 7-中频)
  patterns: [
    { word: '单例模式', weight: 7 },
    { word: '工厂模式', weight: 7 },
    { word: '观察者模式', weight: 7 },
    { word: '策略模式', weight: 6 },
    { word: '装饰器模式', weight: 6 },
    { word: 'MVC', weight: 8 },
    { word: 'MVP', weight: 6 },
    { word: 'MVVM', weight: 7 }
  ],

  // 测试相关 (权重: 7-中频)
  testing: [
    { word: '单元测试', weight: 8 },
    { word: '集成测试', weight: 7 },
    { word: 'E2E测试', weight: 6 },
    { word: 'Jest', weight: 7 },
    { word: 'Mocha', weight: 6 },
    { word: 'Cypress', weight: 6 },
    { word: 'Selenium', weight: 6 }
  ]
};

// 生成热词配置
export function generateHotWords(): Array<{ word: string; weight: number }> {
  const allWords: Array<{ word: string; weight: number }> = [];

  Object.values(PROGRAMMER_HOT_WORDS).forEach(category => {
    allWords.push(...category);
  });

  // 按权重排序，取前100个
  return allWords
    .sort((a, b) => b.weight - a.weight)
    .slice(0, 100);
}
```

### 4.2 热词上传

```typescript
// 热词管理服务
export class HotWordManager {
  private config: TencentASRConfig;

  constructor(config: TencentASRConfig) {
    this.config = config;
  }

  // 创建热词表
  async createHotWordList(name: string, words: Array<{ word: string; weight: number }>): Promise<string> {
    const client = new AsrClient({
      credential: {
        secretId: this.config.secretId,
        secretKey: this.config.secretKey,
      },
      region: this.config.region,
    });

    const params = {
      Name: name,
      Description: '程序员专业词汇热词表',
      WordWeights: words.map(item => ({
        Word: item.word,
        Weight: item.weight
      }))
    };

    try {
      const response = await client.CreateAsrVocab(params);
      return response.VocabId!;
    } catch (error) {
      console.error('创建热词表失败:', error);
      throw error;
    }
  }

  // 更新热词表
  async updateHotWordList(vocabId: string, words: Array<{ word: string; weight: number }>): Promise<void> {
    const client = new AsrClient({
      credential: {
        secretId: this.config.secretId,
        secretKey: this.config.secretKey,
      },
      region: this.config.region,
    });

    const params = {
      VocabId: vocabId,
      WordWeights: words.map(item => ({
        Word: item.word,
        Weight: item.weight
      }))
    };

    try {
      await client.UpdateAsrVocab(params);
      console.log('热词表更新成功');
    } catch (error) {
      console.error('更新热词表失败:', error);
      throw error;
    }
  }
}
```

## 5. 实时识别实现

### 5.1 WebSocket 连接管理

```typescript
import WebSocket from 'ws';
import { EventEmitter } from 'events';

export interface ASRResult {
  voice_id: string;
  message_id: string;
  result: {
    slice_type: number;    // 0-一句话开始，1-一句话结束，2-一句话中间
    index: number;         // 分片索引
    start_time: number;    // 开始时间
    end_time: number;      // 结束时间
    voice_text_str: string; // 识别文本
    word_size: number;     // 词数量
    word_list?: Array<{    // 词列表（当word_info=1时返回）
      word: string;
      start_time: number;
      end_time: number;
      stable_flag: number;
    }>;
  };
  final: number;         // 0-非最终结果，1-最终结果
  code: number;          // 错误码，0表示成功
  message: string;       // 错误信息
}

export class TencentASRClient extends EventEmitter {
  private ws: WebSocket | null = null;
  private config: TencentASRConfig;
  private authParams: AuthParams;
  private isConnected = false;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;

  constructor(config: TencentASRConfig) {
    super();
    this.config = config;
    this.authParams = TencentASRAuth.buildAuthParams(config);
  }

  // 连接WebSocket
  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        // 构建连接URL
        const url = this.buildConnectionURL();

        this.ws = new WebSocket(url);

        this.ws.on('open', () => {
          console.log('ASR WebSocket 连接成功');
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.emit('connected');
          resolve();
        });

        this.ws.on('message', (data: Buffer) => {
          try {
            const result: ASRResult = JSON.parse(data.toString());
            this.handleMessage(result);
          } catch (error) {
            console.error('解析ASR消息失败:', error);
            this.emit('error', error);
          }
        });

        this.ws.on('error', (error) => {
          console.error('ASR WebSocket 错误:', error);
          this.emit('error', error);
          reject(error);
        });

        this.ws.on('close', (code, reason) => {
          console.log(`ASR WebSocket 连接关闭: ${code} - ${reason}`);
          this.isConnected = false;
          this.emit('disconnected', { code, reason });

          // 自动重连
          if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.scheduleReconnect();
          }
        });

      } catch (error) {
        reject(error);
      }
    });
  }

  // 构建连接URL
  private buildConnectionURL(): string {
    const params = new URLSearchParams();

    Object.entries(this.authParams).forEach(([key, value]) => {
      params.append(key, value.toString());
    });

    return `wss://asr.tencentcloudapi.com/asr/v2/${this.config.secretId}?${params.toString()}`;
  }

  // 处理消息
  private handleMessage(result: ASRResult): void {
    if (result.code !== 0) {
      console.error('ASR识别错误:', result.message);
      this.emit('error', new Error(result.message));
      return;
    }

    // 发送识别结果
    this.emit('result', {
      text: result.result.voice_text_str,
      isFinal: result.final === 1,
      sliceType: result.result.slice_type,
      startTime: result.result.start_time,
      endTime: result.result.end_time,
      wordList: result.result.word_list || []
    });

    // 如果是最终结果
    if (result.final === 1) {
      this.emit('finalResult', result.result.voice_text_str);
    }
  }

  // 发送音频数据
  sendAudio(audioData: Buffer): void {
    if (!this.isConnected || !this.ws) {
      console.warn('WebSocket未连接，无法发送音频数据');
      return;
    }

    try {
      this.ws.send(audioData);
    } catch (error) {
      console.error('发送音频数据失败:', error);
      this.emit('error', error);
    }
  }

  // 发送结束标识
  sendEnd(): void {
    if (!this.isConnected || !this.ws) {
      return;
    }

    try {
      // 发送空的Buffer表示音频结束
      this.ws.send(Buffer.alloc(0));
    } catch (error) {
      console.error('发送结束标识失败:', error);
    }
  }

  // 断开连接
  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isConnected = false;
  }

  // 计划重连
  private scheduleReconnect(): void {
    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

    console.log(`${delay}ms后尝试第${this.reconnectAttempts}次重连...`);

    setTimeout(() => {
      this.connect().catch(error => {
        console.error('重连失败:', error);
      });
    }, delay);
  }

  // 获取连接状态
  isConnectedState(): boolean {
    return this.isConnected;
  }
}
```

### 5.2 音频处理

```typescript
// 音频处理工具
export class AudioProcessor {
  private audioContext: AudioContext | null = null;
  private mediaStream: MediaStream | null = null;
  private processor: ScriptProcessorNode | null = null;
  private source: MediaStreamAudioSourceNode | null = null;

  // 初始化音频上下文
  async initialize(): Promise<void> {
    try {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();

      // 请求麦克风权限
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          sampleRate: 16000,      // 16kHz采样率
          channelCount: 1,        // 单声道
          echoCancellation: true, // 回声消除
          noiseSuppression: true, // 噪声抑制
          autoGainControl: true   // 自动增益控制
        }
      });

      console.log('音频初始化成功');
    } catch (error) {
      console.error('音频初始化失败:', error);
      throw error;
    }
  }

  // 开始音频处理
  startProcessing(onAudioData: (audioData: Buffer) => void): void {
    if (!this.audioContext || !this.mediaStream) {
      throw new Error('音频上下文未初始化');
    }

    try {
      // 创建音频源
      this.source = this.audioContext.createMediaStreamSource(this.mediaStream);

      // 创建音频处理器
      this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);

      // 处理音频数据
      this.processor.onaudioprocess = (event) => {
        const inputBuffer = event.inputBuffer;
        const inputData = inputBuffer.getChannelData(0);

        // 转换为16位PCM
        const pcmData = this.convertToPCM16(inputData);
        onAudioData(Buffer.from(pcmData));
      };

      // 连接音频节点
      this.source.connect(this.processor);
      this.processor.connect(this.audioContext.destination);

      console.log('音频处理开始');
    } catch (error) {
      console.error('开始音频处理失败:', error);
      throw error;
    }
  }

  // 停止音频处理
  stopProcessing(): void {
    try {
      if (this.processor) {
        this.processor.disconnect();
        this.processor = null;
      }

      if (this.source) {
        this.source.disconnect();
        this.source = null;
      }

      if (this.mediaStream) {
        this.mediaStream.getTracks().forEach(track => track.stop());
        this.mediaStream = null;
      }

      console.log('音频处理停止');
    } catch (error) {
      console.error('停止音频处理失败:', error);
    }
  }

  // 转换为16位PCM格式
  private convertToPCM16(float32Array: Float32Array): ArrayBuffer {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);

    for (let i = 0; i < float32Array.length; i++) {
      const sample = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(i * 2, sample * 0x7FFF, true);
    }

    return buffer;
  }

  // 获取音量级别
  getVolumeLevel(audioData: Float32Array): number {
    let sum = 0;
    for (let i = 0; i < audioData.length; i++) {
      sum += audioData[i] * audioData[i];
    }
    const rms = Math.sqrt(sum / audioData.length);
    return Math.min(100, Math.floor(rms * 100 * 10)); // 转换为0-100的音量级别
  }

  // 清理资源
  cleanup(): void {
    this.stopProcessing();

    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
  }
}
```

## 6. 错误处理和重连机制

### 6.1 错误类型定义

```typescript
// ASR错误类型
export enum ASRErrorType {
  NETWORK_ERROR = 'NETWORK_ERROR',           // 网络错误
  AUTH_ERROR = 'AUTH_ERROR',                 // 认证错误
  AUDIO_ERROR = 'AUDIO_ERROR',               // 音频错误
  SERVICE_ERROR = 'SERVICE_ERROR',           // 服务错误
  PERMISSION_ERROR = 'PERMISSION_ERROR',     // 权限错误
  TIMEOUT_ERROR = 'TIMEOUT_ERROR'            // 超时错误
}

export class ASRError extends Error {
  public type: ASRErrorType;
  public code?: number;
  public details?: any;

  constructor(type: ASRErrorType, message: string, code?: number, details?: any) {
    super(message);
    this.name = 'ASRError';
    this.type = type;
    this.code = code;
    this.details = details;
  }
}

// 错误处理器
export class ASRErrorHandler {
  static handleError(error: any): ASRError {
    if (error instanceof ASRError) {
      return error;
    }

    // 网络错误
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      return new ASRError(
        ASRErrorType.NETWORK_ERROR,
        '网络连接失败，请检查网络设置',
        error.code,
        error
      );
    }

    // WebSocket错误
    if (error.code === 1006) {
      return new ASRError(
        ASRErrorType.NETWORK_ERROR,
        'WebSocket连接异常关闭',
        error.code,
        error
      );
    }

    // 认证错误
    if (error.message?.includes('signature') || error.message?.includes('auth')) {
      return new ASRError(
        ASRErrorType.AUTH_ERROR,
        '认证失败，请检查密钥配置',
        undefined,
        error
      );
    }

    // 权限错误
    if (error.name === 'NotAllowedError') {
      return new ASRError(
        ASRErrorType.PERMISSION_ERROR,
        '麦克风权限被拒绝，请允许访问麦克风',
        undefined,
        error
      );
    }

    // 音频设备错误
    if (error.name === 'NotFoundError') {
      return new ASRError(
        ASRErrorType.AUDIO_ERROR,
        '未找到音频设备，请检查麦克风连接',
        undefined,
        error
      );
    }

    // 默认服务错误
    return new ASRError(
      ASRErrorType.SERVICE_ERROR,
      error.message || '语音识别服务异常',
      undefined,
      error
    );
  }

  static getErrorMessage(error: ASRError): string {
    const errorMessages = {
      [ASRErrorType.NETWORK_ERROR]: '网络连接失败，请检查网络设置后重试',
      [ASRErrorType.AUTH_ERROR]: '认证失败，请检查密钥配置',
      [ASRErrorType.AUDIO_ERROR]: '音频设备异常，请检查麦克风设置',
      [ASRErrorType.SERVICE_ERROR]: '语音识别服务暂时不可用，请稍后重试',
      [ASRErrorType.PERMISSION_ERROR]: '需要麦克风权限才能使用语音功能',
      [ASRErrorType.TIMEOUT_ERROR]: '请求超时，请检查网络连接'
    };

    return errorMessages[error.type] || error.message;
  }
}
```

### 6.2 重连策略

```typescript
// 重连策略配置
export interface ReconnectConfig {
  maxAttempts: number;      // 最大重连次数
  initialDelay: number;     // 初始延迟时间(ms)
  maxDelay: number;         // 最大延迟时间(ms)
  backoffFactor: number;    // 退避因子
  jitter: boolean;          // 是否添加随机抖动
}

export class ReconnectManager {
  private config: ReconnectConfig;
  private attempts = 0;
  private isReconnecting = false;
  private reconnectTimer: NodeJS.Timeout | null = null;

  constructor(config: Partial<ReconnectConfig> = {}) {
    this.config = {
      maxAttempts: 5,
      initialDelay: 1000,
      maxDelay: 30000,
      backoffFactor: 2,
      jitter: true,
      ...config
    };
  }

  // 开始重连
  async startReconnect(reconnectFn: () => Promise<void>): Promise<void> {
    if (this.isReconnecting) {
      return;
    }

    this.isReconnecting = true;
    this.attempts = 0;

    return this.attemptReconnect(reconnectFn);
  }

  // 尝试重连
  private async attemptReconnect(reconnectFn: () => Promise<void>): Promise<void> {
    if (this.attempts >= this.config.maxAttempts) {
      this.isReconnecting = false;
      throw new ASRError(
        ASRErrorType.NETWORK_ERROR,
        `重连失败，已达到最大重连次数 ${this.config.maxAttempts}`
      );
    }

    this.attempts++;
    const delay = this.calculateDelay();

    console.log(`第 ${this.attempts} 次重连尝试，${delay}ms 后开始...`);

    return new Promise((resolve, reject) => {
      this.reconnectTimer = setTimeout(async () => {
        try {
          await reconnectFn();
          this.isReconnecting = false;
          this.attempts = 0;
          console.log('重连成功');
          resolve();
        } catch (error) {
          console.error(`第 ${this.attempts} 次重连失败:`, error);

          // 继续尝试重连
          try {
            await this.attemptReconnect(reconnectFn);
            resolve();
          } catch (finalError) {
            reject(finalError);
          }
        }
      }, delay);
    });
  }

  // 计算延迟时间
  private calculateDelay(): number {
    let delay = this.config.initialDelay * Math.pow(this.config.backoffFactor, this.attempts - 1);
    delay = Math.min(delay, this.config.maxDelay);

    // 添加随机抖动
    if (this.config.jitter) {
      delay += Math.random() * 1000;
    }

    return Math.floor(delay);
  }

  // 停止重连
  stopReconnect(): void {
    this.isReconnecting = false;

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  // 重置重连状态
  reset(): void {
    this.attempts = 0;
    this.isReconnecting = false;
    this.stopReconnect();
  }

  // 获取重连状态
  getStatus() {
    return {
      isReconnecting: this.isReconnecting,
      attempts: this.attempts,
      maxAttempts: this.config.maxAttempts
    };
  }
}
```

## 7. 完整的语音识别服务

### 7.1 主服务类

```typescript
import { EventEmitter } from 'events';

export interface VoiceRecognitionOptions {
  config: TencentASRConfig;
  hotWordId?: string;
  enableReconnect?: boolean;
  reconnectConfig?: Partial<ReconnectConfig>;
}

export interface RecognitionResult {
  text: string;
  isFinal: boolean;
  confidence?: number;
  startTime: number;
  endTime: number;
  wordList?: Array<{
    word: string;
    startTime: number;
    endTime: number;
    confidence: number;
  }>;
}

export class TencentVoiceRecognitionService extends EventEmitter {
  private asrClient: TencentASRClient;
  private audioProcessor: AudioProcessor;
  private reconnectManager: ReconnectManager;
  private hotWordManager: HotWordManager;

  private isRecording = false;
  private currentVolumeLevel = 0;
  private options: VoiceRecognitionOptions;

  constructor(options: VoiceRecognitionOptions) {
    super();
    this.options = options;

    // 初始化各个组件
    this.asrClient = new TencentASRClient(options.config);
    this.audioProcessor = new AudioProcessor();
    this.hotWordManager = new HotWordManager(options.config);

    if (options.enableReconnect !== false) {
      this.reconnectManager = new ReconnectManager(options.reconnectConfig);
    }

    this.setupEventListeners();
  }

  // 设置事件监听器
  private setupEventListeners(): void {
    // ASR客户端事件
    this.asrClient.on('connected', () => {
      this.emit('connected');
    });

    this.asrClient.on('disconnected', (info) => {
      this.emit('disconnected', info);

      // 如果正在录音且启用了重连，尝试重连
      if (this.isRecording && this.reconnectManager) {
        this.handleReconnect();
      }
    });

    this.asrClient.on('result', (result) => {
      const recognitionResult: RecognitionResult = {
        text: result.text,
        isFinal: result.isFinal,
        startTime: result.startTime,
        endTime: result.endTime,
        wordList: result.wordList?.map(word => ({
          word: word.word,
          startTime: word.start_time,
          endTime: word.end_time,
          confidence: word.stable_flag
        }))
      };

      this.emit('result', recognitionResult);

      if (result.isFinal) {
        this.emit('finalResult', result.text);
      }
    });

    this.asrClient.on('error', (error) => {
      const asrError = ASRErrorHandler.handleError(error);
      this.emit('error', asrError);
    });
  }

  // 初始化热词
  async initializeHotWords(): Promise<void> {
    try {
      const hotWords = generateHotWords();
      const hotWordId = await this.hotWordManager.createHotWordList(
        '程序员专业词汇',
        hotWords
      );

      console.log('热词表创建成功，ID:', hotWordId);
      this.options.hotWordId = hotWordId;
    } catch (error) {
      console.warn('热词初始化失败:', error);
      // 热词失败不影响基本功能
    }
  }

  // 开始语音识别
  async startRecognition(): Promise<void> {
    if (this.isRecording) {
      console.warn('语音识别已在进行中');
      return;
    }

    try {
      this.emit('starting');

      // 1. 初始化音频处理器
      await this.audioProcessor.initialize();

      // 2. 连接ASR服务
      await this.asrClient.connect();

      // 3. 开始音频处理
      this.audioProcessor.startProcessing((audioData) => {
        // 发送音频数据到ASR服务
        this.asrClient.sendAudio(audioData);

        // 计算音量级别
        const volumeLevel = this.calculateVolumeLevel(audioData);
        if (volumeLevel !== this.currentVolumeLevel) {
          this.currentVolumeLevel = volumeLevel;
          this.emit('volumeChange', volumeLevel);
        }
      });

      this.isRecording = true;
      this.emit('started');
      console.log('语音识别开始');

    } catch (error) {
      const asrError = ASRErrorHandler.handleError(error);
      this.emit('error', asrError);
      throw asrError;
    }
  }

  // 停止语音识别
  async stopRecognition(): Promise<void> {
    if (!this.isRecording) {
      return;
    }

    try {
      this.emit('stopping');

      // 1. 停止音频处理
      this.audioProcessor.stopProcessing();

      // 2. 发送结束标识
      this.asrClient.sendEnd();

      // 3. 等待一段时间让最后的结果返回
      await new Promise(resolve => setTimeout(resolve, 500));

      // 4. 断开ASR连接
      this.asrClient.disconnect();

      this.isRecording = false;
      this.currentVolumeLevel = 0;
      this.emit('stopped');
      console.log('语音识别停止');

    } catch (error) {
      const asrError = ASRErrorHandler.handleError(error);
      this.emit('error', asrError);
      throw asrError;
    }
  }

  // 处理重连
  private async handleReconnect(): Promise<void> {
    if (!this.reconnectManager) {
      return;
    }

    try {
      await this.reconnectManager.startReconnect(async () => {
        await this.asrClient.connect();
      });
    } catch (error) {
      console.error('重连失败:', error);
      this.emit('error', ASRErrorHandler.handleError(error));

      // 重连失败，停止录音
      await this.stopRecognition();
    }
  }

  // 计算音量级别
  private calculateVolumeLevel(audioData: Buffer): number {
    // 将Buffer转换为Float32Array进行音量计算
    const samples = new Float32Array(audioData.length / 2);
    const dataView = new DataView(audioData.buffer);

    for (let i = 0; i < samples.length; i++) {
      samples[i] = dataView.getInt16(i * 2, true) / 32768;
    }

    return this.audioProcessor.getVolumeLevel(samples);
  }

  // 更新热词
  async updateHotWords(words: Array<{ word: string; weight: number }>): Promise<void> {
    if (!this.options.hotWordId) {
      console.warn('热词表未初始化，无法更新');
      return;
    }

    try {
      await this.hotWordManager.updateHotWordList(this.options.hotWordId, words);
      console.log('热词表更新成功');
    } catch (error) {
      console.error('热词表更新失败:', error);
      throw ASRErrorHandler.handleError(error);
    }
  }

  // 获取当前状态
  getStatus() {
    return {
      isRecording: this.isRecording,
      isConnected: this.asrClient.isConnectedState(),
      volumeLevel: this.currentVolumeLevel,
      reconnectStatus: this.reconnectManager?.getStatus()
    };
  }

  // 清理资源
  async cleanup(): Promise<void> {
    try {
      if (this.isRecording) {
        await this.stopRecognition();
      }

      this.audioProcessor.cleanup();
      this.reconnectManager?.stopReconnect();

      // 移除所有监听器
      this.removeAllListeners();

      console.log('语音识别服务清理完成');
    } catch (error) {
      console.error('清理资源失败:', error);
    }
  }
}
```

### 7.2 使用示例

```typescript
// 使用示例
async function initializeVoiceRecognition() {
  // 配置信息
  const config: TencentASRConfig = {
    secretId: process.env.TENCENT_SECRET_ID!,
    secretKey: process.env.TENCENT_SECRET_KEY!,
    appId: parseInt(process.env.TENCENT_APP_ID!),
    region: 'ap-beijing',
    engineType: '16k_zh'
  };

  // 创建语音识别服务
  const voiceService = new TencentVoiceRecognitionService({
    config,
    enableReconnect: true,
    reconnectConfig: {
      maxAttempts: 3,
      initialDelay: 1000,
      maxDelay: 10000,
      backoffFactor: 2,
      jitter: true
    }
  });

  // 设置事件监听器
  voiceService.on('started', () => {
    console.log('语音识别已开始');
  });

  voiceService.on('result', (result: RecognitionResult) => {
    console.log('识别结果:', result.text);
    if (result.isFinal) {
      console.log('最终结果:', result.text);
      // 发送到AI服务获取回答
      handleRecognitionResult(result.text);
    }
  });

  voiceService.on('volumeChange', (level: number) => {
    console.log('音量级别:', level);
    // 更新UI音量指示器
    updateVolumeIndicator(level);
  });

  voiceService.on('error', (error: ASRError) => {
    console.error('语音识别错误:', ASRErrorHandler.getErrorMessage(error));
    // 显示错误提示
    showErrorMessage(ASRErrorHandler.getErrorMessage(error));
  });

  // 初始化热词
  try {
    await voiceService.initializeHotWords();
  } catch (error) {
    console.warn('热词初始化失败，将使用默认识别:', error);
  }

  return voiceService;
}

// 处理识别结果
async function handleRecognitionResult(text: string) {
  try {
    // 发送到AI服务
    const aiResponse = await aiService.getResponse(text, 'normal');
    console.log('AI回答:', aiResponse);

    // 更新UI显示
    updateUIWithResult(text, aiResponse);
  } catch (error) {
    console.error('获取AI回答失败:', error);
  }
}

// 更新UI
function updateUIWithResult(question: string, answer: string) {
  // 更新问题显示
  document.getElementById('question-text')!.textContent = question;

  // 更新回答显示
  document.getElementById('answer-text')!.textContent = answer;
}

// 更新音量指示器
function updateVolumeIndicator(level: number) {
  const indicator = document.getElementById('volume-indicator');
  if (indicator) {
    indicator.style.width = `${level}%`;
  }
}

// 显示错误消息
function showErrorMessage(message: string) {
  // 显示错误提示UI
  console.error(message);
}
```

## 8. 环境配置

### 8.1 环境变量配置

```bash
# .env 文件
# 腾讯云配置
TENCENT_SECRET_ID=your_secret_id_here
TENCENT_SECRET_KEY=your_secret_key_here
TENCENT_APP_ID=your_app_id_here
TENCENT_REGION=ap-beijing

# 语音识别配置
ASR_ENGINE_TYPE=16k_zh
ASR_SAMPLE_RATE=16000
ASR_ENABLE_HOT_WORDS=true
ASR_ENABLE_RECONNECT=true
ASR_MAX_RECONNECT_ATTEMPTS=3

# 调试配置
DEBUG_ASR=false
LOG_LEVEL=info
```

### 8.2 TypeScript 类型声明

```typescript
// types/tencent-asr.d.ts
declare module 'tencentcloud-sdk-nodejs' {
  export class AsrClient {
    constructor(config: {
      credential: {
        secretId: string;
        secretKey: string;
      };
      region: string;
    });

    CreateAsrVocab(params: {
      Name: string;
      Description: string;
      WordWeights: Array<{
        Word: string;
        Weight: number;
      }>;
    }): Promise<{ VocabId: string }>;

    UpdateAsrVocab(params: {
      VocabId: string;
      WordWeights: Array<{
        Word: string;
        Weight: number;
      }>;
    }): Promise<void>;
  }
}
```

## 9. 测试和调试

### 9.1 单元测试

```typescript
// tests/TencentASRClient.test.ts
import { TencentASRClient, TencentASRConfig } from '../src/TencentASRClient';

describe('TencentASRClient', () => {
  let client: TencentASRClient;
  let config: TencentASRConfig;

  beforeEach(() => {
    config = {
      secretId: 'test_secret_id',
      secretKey: 'test_secret_key',
      appId: 12345,
      region: 'ap-beijing',
      engineType: '16k_zh'
    };

    client = new TencentASRClient(config);
  });

  afterEach(async () => {
    await client.disconnect();
  });

  test('应该能够创建客户端实例', () => {
    expect(client).toBeInstanceOf(TencentASRClient);
  });

  test('应该能够生成正确的连接URL', () => {
    const url = client['buildConnectionURL']();
    expect(url).toContain('wss://asr.tencentcloudapi.com');
    expect(url).toContain('secretid=test_secret_id');
  });

  test('应该能够处理连接错误', async () => {
    const errorHandler = jest.fn();
    client.on('error', errorHandler);

    // 模拟连接失败
    await expect(client.connect()).rejects.toThrow();
    expect(errorHandler).toHaveBeenCalled();
  });
});
```

### 9.2 集成测试

```typescript
// tests/integration/voice-recognition.test.ts
import { TencentVoiceRecognitionService } from '../src/TencentVoiceRecognitionService';

describe('语音识别集成测试', () => {
  let service: TencentVoiceRecognitionService;

  beforeAll(async () => {
    service = new TencentVoiceRecognitionService({
      config: {
        secretId: process.env.TENCENT_SECRET_ID!,
        secretKey: process.env.TENCENT_SECRET_KEY!,
        appId: parseInt(process.env.TENCENT_APP_ID!),
        region: 'ap-beijing',
        engineType: '16k_zh'
      }
    });
  });

  afterAll(async () => {
    await service.cleanup();
  });

  test('应该能够初始化热词表', async () => {
    await expect(service.initializeHotWords()).resolves.not.toThrow();
  });

  test('应该能够开始和停止识别', async () => {
    await expect(service.startRecognition()).resolves.not.toThrow();
    await new Promise(resolve => setTimeout(resolve, 1000));
    await expect(service.stopRecognition()).resolves.not.toThrow();
  });
});
```

## 10. 性能优化建议

### 10.1 音频处理优化

- 使用 Web Audio API 的 AudioWorklet 替代 ScriptProcessorNode（已废弃）
- 实现音频数据缓冲，避免频繁发送小数据包
- 添加静音检测，减少无效数据传输

### 10.2 网络优化

- 实现智能重连策略，根据网络状况调整重连间隔
- 添加网络质量检测，动态调整音频质量
- 使用连接池管理多个WebSocket连接

### 10.3 内存优化

- 及时释放音频缓冲区
- 实现对象池复用AudioBuffer
- 定期清理事件监听器

## 11. 常见问题解决

### 11.1 连接问题

**问题**: WebSocket连接失败
**解决方案**:

1. 检查网络连接
2. 验证密钥配置
3. 确认签名算法正确
4. 检查防火墙设置

### 11.2 音频问题

**问题**: 麦克风权限被拒绝
**解决方案**:

1. 引导用户手动授权
2. 提供权限设置指南
3. 实现权限状态检测

### 11.3 识别准确率问题

**问题**: 程序员词汇识别不准确
**解决方案**:

1. 完善热词库
2. 调整词汇权重
3. 使用自定义语言模型
4. 优化音频质量

这个完整的腾讯云实时语音识别集成方案包含了所有必要的组件和功能，特别针对程序员词汇进行了优化，应该能很好地满足你的AI面试助手项目需求。
