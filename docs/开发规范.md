# AI面试助手桌面端开发规范

## 1. 代码规范

### 1.1 TypeScript 编码规范

#### 1.1.1 命名规范

```typescript
// ✅ 正确的命名方式
// 变量和函数使用 camelCase
const userName = 'john';
const getUserInfo = () => {};

// 类名使用 PascalCase
class VoiceRecognitionService {}

// 接口使用 PascalCase
interface UserSettings {}

// 类型别名使用 PascalCase
type ResponseMode = 'simple' | 'normal' | 'detailed';

// 枚举使用 PascalCase
enum WindowState {
  MINIMIZED = 'minimized',
  HIDDEN = 'hidden',
  VISIBLE = 'visible'
}

// 常量使用 SCREAMING_SNAKE_CASE
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = 'https://api.example.com';

// 文件名使用 kebab-case
// voice-recorder.component.tsx
// user-settings.service.ts
// api-client.utils.ts

// 目录名使用 kebab-case
// voice-recognition/
// user-settings/
// api-services/
```

#### 1.1.2 类型定义规范

```typescript
// ✅ 推荐的类型定义方式
// 使用接口定义对象类型
interface VoiceSettings {
  readonly deviceId: string;
  sensitivity: number;
  noiseReduction: boolean;
  autoStart?: boolean; // 可选属性使用 ?
}

// 使用类型别名定义联合类型
type Theme = 'light' | 'dark' | 'auto';
type Status = 'idle' | 'loading' | 'success' | 'error';

// 泛型使用有意义的名称
interface ApiResponse<TData = unknown> {
  data: TData;
  message: string;
  code: number;
}

// 函数类型定义
type EventHandler<T = Event> = (event: T) => void;
type AsyncFunction<T, R> = (param: T) => Promise<R>;

// ❌ 避免的写法
// 不要使用 any
const data: any = {}; // 应该定义具体类型

// 不要使用 Function 类型
const callback: Function = () => {}; // 应该定义具体的函数签名
```

#### 1.1.3 函数定义规范

```typescript
// ✅ 推荐的函数定义方式
// 使用箭头函数定义简单函数
const calculateVolume = (input: number): number => {
  return Math.max(0, Math.min(100, input));
};

// 使用 async/await 处理异步操作
const fetchUserData = async (userId: string): Promise<User> => {
  try {
    const response = await apiClient.get(`/users/${userId}`);
    return response.data;
  } catch (error) {
    logger.error('获取用户数据失败:', error);
    throw new Error('用户数据获取失败');
  }
};

// 使用函数重载定义多种调用方式
function processVoiceInput(text: string): string;
function processVoiceInput(audio: ArrayBuffer): Promise<string>;
function processVoiceInput(input: string | ArrayBuffer): string | Promise<string> {
  if (typeof input === 'string') {
    return input.trim();
  }
  return processAudioBuffer(input);
}

// 使用泛型约束
const createService = <T extends BaseService>(
  ServiceClass: new () => T
): T => {
  return new ServiceClass();
};
```

### 1.2 React 组件规范

#### 1.2.1 组件定义规范

```typescript
// ✅ 推荐的组件定义方式
import React, { useState, useEffect, useCallback } from 'react';
import { VoiceRecorderProps } from './VoiceRecorder.types';
import { Container, Button } from './VoiceRecorder.styled';

export const VoiceRecorder: React.FC<VoiceRecorderProps> = ({
  onStart,
  onStop,
  onResult,
  disabled = false,
  className
}) => {
  // 状态定义
  const [isRecording, setIsRecording] = useState(false);
  const [volume, setVolume] = useState(0);

  // 副作用处理
  useEffect(() => {
    if (isRecording) {
      startVoiceRecognition();
    } else {
      stopVoiceRecognition();
    }

    return () => {
      cleanup();
    };
  }, [isRecording]);

  // 事件处理函数
  const handleStartRecording = useCallback(() => {
    if (disabled) return;
    setIsRecording(true);
    onStart?.();
  }, [disabled, onStart]);

  const handleStopRecording = useCallback(() => {
    setIsRecording(false);
    onStop?.();
  }, [onStop]);

  // 渲染
  return (
    <Container className={className}>
      <Button
        onClick={isRecording ? handleStopRecording : handleStartRecording}
        disabled={disabled}
        $isRecording={isRecording}
      >
        {isRecording ? '停止' : '开始'}
      </Button>
    </Container>
  );
};

// 默认导出
export default VoiceRecorder;
```

#### 1.2.2 Props 类型定义

```typescript
// VoiceRecorder.types.ts
export interface VoiceRecorderProps {
  // 必需属性
  onStart: () => void;
  onStop: () => void;
  onResult: (text: string) => void;

  // 可选属性
  disabled?: boolean;
  className?: string;
  autoStart?: boolean;

  // 配置对象
  settings?: {
    sensitivity: number;
    noiseReduction: boolean;
  };

  // 子组件
  children?: React.ReactNode;
}

// 默认属性
export const defaultVoiceRecorderProps: Partial<VoiceRecorderProps> = {
  disabled: false,
  autoStart: false,
  settings: {
    sensitivity: 5,
    noiseReduction: true,
  },
};
```

#### 1.2.3 自定义 Hook 规范

```typescript
// useVoiceRecognition.ts
import { useState, useEffect, useCallback, useRef } from 'react';

interface UseVoiceRecognitionOptions {
  autoStart?: boolean;
  sensitivity?: number;
  onResult?: (text: string) => void;
  onError?: (error: Error) => void;
}

interface UseVoiceRecognitionReturn {
  isRecording: boolean;
  volume: number;
  lastResult: string;
  startRecording: () => void;
  stopRecording: () => void;
  clearResult: () => void;
}

export const useVoiceRecognition = (
  options: UseVoiceRecognitionOptions = {}
): UseVoiceRecognitionReturn => {
  const {
    autoStart = false,
    sensitivity = 5,
    onResult,
    onError
  } = options;

  // 状态管理
  const [isRecording, setIsRecording] = useState(false);
  const [volume, setVolume] = useState(0);
  const [lastResult, setLastResult] = useState('');

  // 引用管理
  const recognitionRef = useRef<SpeechRecognition | null>(null);
  const streamRef = useRef<MediaStream | null>(null);

  // 开始录音
  const startRecording = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      setIsRecording(true);

      // 初始化语音识别
      initializeSpeechRecognition();
    } catch (error) {
      onError?.(error as Error);
    }
  }, [onError]);

  // 停止录音
  const stopRecording = useCallback(() => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }

    if (recognitionRef.current) {
      recognitionRef.current.stop();
    }

    setIsRecording(false);
    setVolume(0);
  }, []);

  // 清除结果
  const clearResult = useCallback(() => {
    setLastResult('');
  }, []);

  // 初始化语音识别
  const initializeSpeechRecognition = useCallback(() => {
    // 实现语音识别逻辑
  }, [sensitivity, onResult]);

  // 自动开始
  useEffect(() => {
    if (autoStart) {
      startRecording();
    }

    return () => {
      stopRecording();
    };
  }, [autoStart, startRecording, stopRecording]);

  return {
    isRecording,
    volume,
    lastResult,
    startRecording,
    stopRecording,
    clearResult,
  };
};
```

### 1.3 样式规范

#### 1.3.1 Styled Components 规范

```typescript
// VoiceRecorder.styled.ts
import styled, { css, keyframes } from 'styled-components';

// 动画定义
const pulseAnimation = keyframes`
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.05); opacity: 0.8; }
  100% { transform: scale(1); opacity: 1; }
`;

// 基础容器
export const Container = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  padding: 20px;
  background: var(--primary-bg);
  border-radius: 12px;
  border: 1px solid var(--border-color);
`;

// 按钮组件，使用 $ 前缀标识 transient props
export const Button = styled.button<{
  $isRecording?: boolean;
  $disabled?: boolean;
}>`
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: none;
  background: var(--accent-color);
  color: white;
  font-size: 24px;
  cursor: pointer;
  transition: all 0.2s ease;

  ${({ $isRecording }) =>
    $isRecording &&
    css`
      background: var(--error-color);
      animation: ${pulseAnimation} 1.5s infinite;
    `}

  ${({ $disabled }) =>
    $disabled &&
    css`
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    `}

  &:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }

  &:active {
    transform: translateY(0);
  }
`;

// 状态指示器
export const StatusIndicator = styled.div<{ $isActive: boolean }>`
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;

  ${({ $isActive }) =>
    $isActive
      ? css`
          background: var(--success-color);
          color: white;
        `
      : css`
          background: var(--secondary-bg);
          color: var(--text-secondary);
        `}
`;
```

#### 1.3.2 CSS 变量规范

```css
/* styles/variables.css */
:root {
  /* 颜色系统 */
  --primary-bg: #1a1a1a;
  --secondary-bg: #2d2d2d;
  --accent-color: #007acc;
  --text-primary: #ffffff;
  --text-secondary: #b3b3b3;
  --border-color: #404040;

  /* 状态颜色 */
  --success-color: #52c41a;
  --warning-color: #faad14;
  --error-color: #ff4d4f;
  --info-color: #1890ff;

  /* 间距系统 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* 字体系统 */
  --font-size-xs: 12px;
  --font-size-sm: 14px;
  --font-size-md: 16px;
  --font-size-lg: 18px;
  --font-size-xl: 20px;

  /* 圆角系统 */
  --border-radius-sm: 4px;
  --border-radius-md: 8px;
  --border-radius-lg: 12px;
  --border-radius-xl: 16px;

  /* 阴影系统 */
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);

  /* 过渡动画 */
  --transition-fast: 0.15s ease;
  --transition-normal: 0.2s ease;
  --transition-slow: 0.3s ease;
}
```

## 2. 项目结构规范

### 2.1 文件组织规范

```
src/renderer/components/
├── common/                    # 通用组件
│   ├── Button/
│   │   ├── index.tsx         # 主文件
│   │   ├── Button.types.ts   # 类型定义
│   │   ├── Button.styled.ts  # 样式文件
│   │   ├── Button.test.tsx   # 测试文件
│   │   └── Button.stories.tsx # Storybook 文件
│   └── ...
├── layout/                    # 布局组件
├── business/                  # 业务组件
└── pages/                     # 页面组件
```

### 2.2 导入导出规范

```typescript
// ✅ 推荐的导入方式
// 第三方库导入
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import styled from 'styled-components';

// 内部模块导入（按路径层级排序）
import { Button } from '@renderer/components/common/Button';
import { useVoiceRecognition } from '@renderer/hooks/useVoiceRecognition';
import { VoiceService } from '@renderer/services/VoiceService';
import { logger } from '@shared/utils/logger';

// 类型导入
import type { VoiceRecorderProps } from './VoiceRecorder.types';
import type { RootState } from '@renderer/store';

// ✅ 推荐的导出方式
// 命名导出（推荐）
export const VoiceRecorder: React.FC<VoiceRecorderProps> = () => {
  // 组件实现
};

// 默认导出（用于页面组件）
export default VoiceRecorder;

// 类型导出
export type { VoiceRecorderProps };

// 批量导出
export {
  VoiceRecorder,
  VoiceRecorderProps,
  useVoiceRecognition,
};
```

### 2.3 文件命名规范

```
# 组件文件
VoiceRecorder.tsx              # React 组件
VoiceRecorder.types.ts         # 类型定义
VoiceRecorder.styled.ts        # 样式文件
VoiceRecorder.test.tsx         # 测试文件
VoiceRecorder.stories.tsx      # Storybook 文件

# 服务文件
VoiceService.ts                # 服务类
voice.service.ts               # 服务函数

# 工具文件
voice.utils.ts                 # 工具函数
voice.constants.ts             # 常量定义
voice.types.ts                 # 类型定义

# Hook 文件
useVoiceRecognition.ts         # 自定义 Hook
useVoiceRecognition.test.ts    # Hook 测试

# 页面文件
MainPage.tsx                   # 页面组件
main-page.route.ts             # 路由配置
```

## 3. Git 提交规范

### 3.1 提交信息格式

```bash
# 提交信息格式
<type>(<scope>): <subject>

<body>

<footer>
```

### 3.2 提交类型

```bash
# 主要类型
feat:     新功能
fix:      修复 bug
docs:     文档更新
style:    代码格式调整（不影响功能）
refactor: 重构代码
perf:     性能优化
test:     测试相关
chore:    构建过程或辅助工具的变动

# 示例
feat(voice): 添加语音识别功能
fix(ui): 修复按钮点击无响应问题
docs(readme): 更新安装说明
style(components): 统一组件代码格式
refactor(services): 重构 API 服务层
perf(voice): 优化语音处理性能
test(components): 添加按钮组件测试
chore(deps): 更新依赖包版本
```

### 3.3 分支管理规范

```bash
# 分支命名规范
main                    # 主分支
develop                 # 开发分支
feature/voice-recognition  # 功能分支
bugfix/login-error      # 修复分支
hotfix/critical-bug     # 热修复分支
release/v1.0.0          # 发布分支

# 分支工作流
1. 从 develop 创建 feature 分支
2. 在 feature 分支开发功能
3. 完成后创建 PR 到 develop
4. 代码审查通过后合并
5. 定期从 develop 创建 release 分支
6. 测试通过后合并到 main 并打标签
```

## 4. 代码审查规范

### 4.1 审查清单

```markdown
## 代码审查清单

### 功能性
- [ ] 代码实现符合需求
- [ ] 边界条件处理正确
- [ ] 错误处理完善
- [ ] 性能表现良好

### 代码质量
- [ ] 代码结构清晰
- [ ] 命名规范合理
- [ ] 注释充分准确
- [ ] 无重复代码

### 安全性
- [ ] 输入验证完善
- [ ] 敏感信息保护
- [ ] 权限控制正确
- [ ] 无安全漏洞

### 测试
- [ ] 单元测试覆盖
- [ ] 集成测试通过
- [ ] 边界测试完整
- [ ] 性能测试达标
```

### 4.2 审查流程

```markdown
1. 自检阶段
   - 开发者自行检查代码
   - 运行所有测试
   - 确保构建成功

2. 同行审查
   - 至少一名同事审查
   - 关注代码质量和逻辑
   - 提出改进建议

3. 技术负责人审查
   - 架构设计合理性
   - 技术方案可行性
   - 代码规范遵循

4. 最终确认
   - 所有问题解决
   - 测试全部通过
   - 文档更新完成
```

## 5. 测试规范

### 5.1 单元测试规范

```typescript
// VoiceRecorder.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { VoiceRecorder } from './VoiceRecorder';
import { VoiceRecorderProps } from './VoiceRecorder.types';

// 模拟依赖
jest.mock('@renderer/hooks/useVoiceRecognition', () => ({
  useVoiceRecognition: jest.fn(() => ({
    isRecording: false,
    volume: 0,
    startRecording: jest.fn(),
    stopRecording: jest.fn(),
  })),
}));

describe('VoiceRecorder', () => {
  const defaultProps: VoiceRecorderProps = {
    onStart: jest.fn(),
    onStop: jest.fn(),
    onResult: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('应该正确渲染组件', () => {
    render(<VoiceRecorder {...defaultProps} />);

    expect(screen.getByRole('button')).toBeInTheDocument();
    expect(screen.getByText('开始')).toBeInTheDocument();
  });

  it('点击按钮应该开始录音', async () => {
    render(<VoiceRecorder {...defaultProps} />);

    const button = screen.getByRole('button');
    fireEvent.click(button);

    await waitFor(() => {
      expect(defaultProps.onStart).toHaveBeenCalledTimes(1);
    });
  });

  it('禁用状态下不应该响应点击', () => {
    render(<VoiceRecorder {...defaultProps} disabled />);

    const button = screen.getByRole('button');
    fireEvent.click(button);

    expect(defaultProps.onStart).not.toHaveBeenCalled();
  });

  it('应该正确处理录音状态变化', () => {
    const { rerender } = render(<VoiceRecorder {...defaultProps} />);

    // 模拟录音状态
    jest.mocked(useVoiceRecognition).mockReturnValue({
      isRecording: true,
      volume: 50,
      startRecording: jest.fn(),
      stopRecording: jest.fn(),
    });

    rerender(<VoiceRecorder {...defaultProps} />);

    expect(screen.getByText('停止')).toBeInTheDocument();
  });
});
```

### 5.2 集成测试规范

```typescript
// voice-workflow.integration.test.ts
import { app } from 'electron';
import { VoiceService } from '@renderer/services/VoiceService';
import { AIService } from '@renderer/services/AIService';

describe('语音识别工作流集成测试', () => {
  let voiceService: VoiceService;
  let aiService: AIService;

  beforeAll(async () => {
    // 初始化测试环境
    voiceService = new VoiceService();
    aiService = new AIService();
  });

  afterAll(async () => {
    // 清理测试环境
    await voiceService.cleanup();
  });

  it('应该完成完整的语音识别到AI回答流程', async () => {
    // 1. 开始语音识别
    await voiceService.startRecognition();
    expect(voiceService.isRecording).toBe(true);

    // 2. 模拟语音输入
    const mockAudioData = new ArrayBuffer(1024);
    const recognitionResult = await voiceService.processAudio(mockAudioData);
    expect(recognitionResult).toBeDefined();

    // 3. 获取AI回答
    const aiResponse = await aiService.getResponse(recognitionResult, 'normal');
    expect(aiResponse).toBeDefined();
    expect(aiResponse.length).toBeGreaterThan(0);

    // 4. 停止语音识别
    await voiceService.stopRecognition();
    expect(voiceService.isRecording).toBe(false);
  });
});
```

### 5.3 E2E 测试规范

```typescript
// login-flow.e2e.test.ts
import { Application } from 'spectron';
import { resolve } from 'path';

describe('登录流程 E2E 测试', () => {
  let app: Application;

  beforeAll(async () => {
    app = new Application({
      path: resolve(__dirname, '../../../node_modules/.bin/electron'),
      args: [resolve(__dirname, '../../../build/main/index.js')],
    });

    await app.start();
  });

  afterAll(async () => {
    if (app && app.isRunning()) {
      await app.stop();
    }
  });

  it('应该显示登录界面', async () => {
    const windowCount = await app.client.getWindowCount();
    expect(windowCount).toBe(1);

    const title = await app.client.getTitle();
    expect(title).toBe('AI面试助手');

    const emailInput = await app.client.$('input[type="email"]');
    expect(await emailInput.isDisplayed()).toBe(true);
  });

  it('应该能够完成登录流程', async () => {
    // 输入邮箱
    await app.client.$('input[type="email"]').setValue('test@example.com');

    // 点击发送验证码
    await app.client.$('button[data-testid="send-code"]').click();

    // 等待验证码输入框出现
    await app.client.waitForExist('input[data-testid="verification-code"]');

    // 输入验证码
    await app.client.$('input[data-testid="verification-code"]').setValue('123456');

    // 点击登录
    await app.client.$('button[data-testid="login"]').click();

    // 验证登录成功
    await app.client.waitForExist('[data-testid="main-interface"]');
    const mainInterface = await app.client.$('[data-testid="main-interface"]');
    expect(await mainInterface.isDisplayed()).toBe(true);
  });
});
```

## 6. 性能优化规范

### 6.1 React 性能优化

```typescript
// ✅ 使用 React.memo 优化组件渲染
export const VoiceRecorder = React.memo<VoiceRecorderProps>(({
  onStart,
  onStop,
  disabled
}) => {
  // 组件实现
}, (prevProps, nextProps) => {
  // 自定义比较函数
  return prevProps.disabled === nextProps.disabled;
});

// ✅ 使用 useCallback 优化函数引用
const handleStart = useCallback(() => {
  if (!disabled) {
    onStart();
  }
}, [disabled, onStart]);

// ✅ 使用 useMemo 优化计算结果
const processedData = useMemo(() => {
  return expensiveCalculation(rawData);
}, [rawData]);

// ✅ 使用 lazy loading 优化组件加载
const SettingsPage = lazy(() => import('./pages/SettingsPage'));

// ✅ 使用 Suspense 处理加载状态
<Suspense fallback={<Loading />}>
  <SettingsPage />
</Suspense>
```

### 6.2 内存管理规范

```typescript
// ✅ 正确清理副作用
useEffect(() => {
  const subscription = voiceService.subscribe(handleVoiceResult);
  const timer = setInterval(updateVolume, 100);

  return () => {
    subscription.unsubscribe();
    clearInterval(timer);
  };
}, []);

// ✅ 正确管理事件监听器
useEffect(() => {
  const handleKeyPress = (event: KeyboardEvent) => {
    // 处理按键事件
  };

  window.addEventListener('keydown', handleKeyPress);

  return () => {
    window.removeEventListener('keydown', handleKeyPress);
  };
}, []);

// ✅ 正确管理 WebSocket 连接
useEffect(() => {
  const ws = new WebSocket('wss://api.example.com');

  ws.onmessage = handleMessage;
  ws.onerror = handleError;

  return () => {
    ws.close();
  };
}, []);
```

## 7. 错误处理规范

### 7.1 错误边界

```typescript
// ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { logger } from '@shared/utils/logger';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    logger.error('React Error Boundary caught an error:', {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
    });
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="error-fallback">
          <h2>出现了一些问题</h2>
          <p>请刷新页面重试，如果问题持续存在，请联系技术支持。</p>
          <button onClick={() => window.location.reload()}>
            刷新页面
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 7.2 异步错误处理

```typescript
// ✅ 推荐的异步错误处理方式
const fetchUserData = async (userId: string): Promise<User | null> => {
  try {
    const response = await apiClient.get(`/users/${userId}`);
    return response.data;
  } catch (error) {
    // 记录错误
    logger.error('获取用户数据失败:', {
      userId,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });

    // 根据错误类型进行不同处理
    if (error instanceof NetworkError) {
      throw new Error('网络连接失败，请检查网络设置');
    } else if (error instanceof AuthError) {
      throw new Error('认证失败，请重新登录');
    } else {
      throw new Error('获取用户数据失败，请稍后重试');
    }
  }
};

// ✅ 使用 Result 模式处理错误
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

const safeApiCall = async <T>(
  apiCall: () => Promise<T>
): Promise<Result<T>> => {
  try {
    const data = await apiCall();
    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error))
    };
  }
};

// 使用示例
const result = await safeApiCall(() => fetchUserData('123'));
if (result.success) {
  console.log('用户数据:', result.data);
} else {
  console.error('获取失败:', result.error.message);
}
```

## 8. 安全规范

### 8.1 输入验证

```typescript
// ✅ 输入验证工具
import { z } from 'zod';

// 定义验证模式
const EmailSchema = z.string().email('请输入有效的邮箱地址');
const PasswordSchema = z.string()
  .min(8, '密码至少8位')
  .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, '密码必须包含大小写字母和数字');

const UserInputSchema = z.object({
  email: EmailSchema,
  password: PasswordSchema,
  age: z.number().min(18, '年龄必须大于18岁').max(120, '年龄不能超过120岁'),
});

// 验证函数
export const validateUserInput = (input: unknown) => {
  try {
    return UserInputSchema.parse(input);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors[0].message);
    }
    throw error;
  }
};

// 使用示例
const handleSubmit = (formData: unknown) => {
  try {
    const validatedData = validateUserInput(formData);
    // 处理验证通过的数据
  } catch (error) {
    if (error instanceof ValidationError) {
      showErrorMessage(error.message);
    }
  }
};
```

### 8.2 敏感数据处理

```typescript
// ✅ 敏感数据加密存储
import CryptoJS from 'crypto-js';

class SecureStorage {
  private readonly secretKey: string;

  constructor() {
    // 从环境变量或安全位置获取密钥
    this.secretKey = process.env.ENCRYPTION_KEY || this.generateKey();
  }

  // 加密存储
  setSecureItem(key: string, value: string): void {
    const encrypted = CryptoJS.AES.encrypt(value, this.secretKey).toString();
    localStorage.setItem(key, encrypted);
  }

  // 解密读取
  getSecureItem(key: string): string | null {
    const encrypted = localStorage.getItem(key);
    if (!encrypted) return null;

    try {
      const decrypted = CryptoJS.AES.decrypt(encrypted, this.secretKey);
      return decrypted.toString(CryptoJS.enc.Utf8);
    } catch (error) {
      logger.error('解密失败:', error);
      return null;
    }
  }

  // 删除敏感数据
  removeSecureItem(key: string): void {
    localStorage.removeItem(key);
  }

  private generateKey(): string {
    return CryptoJS.lib.WordArray.random(256/8).toString();
  }
}

// 使用示例
const secureStorage = new SecureStorage();
secureStorage.setSecureItem('user_token', 'sensitive_token_value');
const token = secureStorage.getSecureItem('user_token');
```

### 8.3 XSS 防护

```typescript
// ✅ XSS 防护工具
import DOMPurify from 'dompurify';

// 清理 HTML 内容
export const sanitizeHTML = (html: string): string => {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
    ALLOWED_ATTR: [],
  });
};

// 转义用户输入
export const escapeHTML = (text: string): string => {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
};

// React 组件中安全渲染
const SafeContent: React.FC<{ content: string }> = ({ content }) => {
  const sanitizedContent = useMemo(() => sanitizeHTML(content), [content]);

  return (
    <div
      dangerouslySetInnerHTML={{ __html: sanitizedContent }}
    />
  );
};
```

## 9. 文档规范

### 9.1 代码注释规范

```typescript
/**
 * 语音识别服务类
 *
 * 提供语音识别、音频处理等功能
 * 支持多种语音识别引擎和配置选项
 *
 * @example
 * ```typescript
 * const voiceService = new VoiceService({
 *   engine: 'tencent',
 *   language: 'zh-CN'
 * });
 *
 * await voiceService.startRecognition();
 * ```
 */
export class VoiceService {
  private recognition: SpeechRecognition | null = null;
  private isRecording = false;

  /**
   * 构造函数
   *
   * @param options - 配置选项
   * @param options.engine - 语音识别引擎 ('tencent' | 'baidu' | 'ali')
   * @param options.language - 识别语言，默认 'zh-CN'
   * @param options.continuous - 是否连续识别，默认 true
   */
  constructor(private options: VoiceServiceOptions) {
    this.initializeRecognition();
  }

  /**
   * 开始语音识别
   *
   * @throws {PermissionError} 当麦克风权限被拒绝时
   * @throws {NotSupportedError} 当浏览器不支持语音识别时
   *
   * @returns Promise<void>
   */
  async startRecognition(): Promise<void> {
    if (this.isRecording) {
      logger.warn('语音识别已在进行中');
      return;
    }

    try {
      await this.requestMicrophonePermission();
      this.recognition?.start();
      this.isRecording = true;
      logger.info('语音识别已开始');
    } catch (error) {
      logger.error('启动语音识别失败:', error);
      throw error;
    }
  }

  /**
   * 停止语音识别
   *
   * @returns void
   */
  stopRecognition(): void {
    if (!this.isRecording) return;

    this.recognition?.stop();
    this.isRecording = false;
    logger.info('语音识别已停止');
  }

  /**
   * 请求麦克风权限
   *
   * @private
   * @returns Promise<void>
   */
  private async requestMicrophonePermission(): Promise<void> {
    // 实现细节...
  }
}
```

### 9.2 README 文档规范

```markdown
# AI面试助手桌面端

## 项目简介

AI面试助手是一款基于 Electron + React + TypeScript 开发的桌面应用，旨在为面试者提供实时的AI辅助回答功能。

## 核心功能

- 🎤 **实时语音识别**: 支持腾讯云、百度云等多种语音识别服务
- 🤖 **AI智能回答**: 接入智谱AI，提供精准的面试问题回答
- 👻 **屏幕共享躲避**: 自动检测屏幕共享并隐藏应用
- ⌨️ **全局快捷键**: 支持自定义快捷键控制
- 🎨 **界面透明度**: 可调节窗口透明度，融入桌面环境
- 🔐 **安全登录**: 邮箱验证码登录，保护用户隐私

## 技术栈

- **主框架**: Electron 28+
- **前端**: React 18 + TypeScript 5
- **UI库**: Ant Design + Styled Components
- **状态管理**: Redux Toolkit + RTK Query
- **构建工具**: Webpack 5 + Babel
- **测试框架**: Jest + React Testing Library
- **代码规范**: ESLint + Prettier + Husky

## 快速开始

### 环境要求

- Node.js >= 18.0.0
- npm >= 8.0.0 或 yarn >= 1.22.0

### 安装依赖

```bash
# 使用 npm
npm install

# 或使用 yarn
yarn install
```

### 开发模式

```bash
# 启动开发服务器
npm run dev

# 或
yarn dev
```

### 构建应用

```bash
# 构建生产版本
npm run build

# 打包应用
npm run dist

# 针对特定平台打包
npm run dist:win    # Windows
npm run dist:mac    # macOS
npm run dist:linux  # Linux
```

## 项目结构

```
src/
├── main/           # 主进程代码
├── renderer/       # 渲染进程代码
├── shared/         # 共享代码
└── assets/         # 静态资源
```

详细的项目结构说明请参考 [项目结构设计文档](docs/项目结构设计.md)。

## 开发指南

- [技术架构设计](docs/技术架构设计.md)
- [功能交互设计](docs/功能交互设计.md)
- [视觉UI原型](docs/视觉UI原型.md)
- [开发规范](docs/开发规范.md)

## 贡献指南

1. Fork 本仓库
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 创建 Pull Request

## 许可证

本项目采用 MIT 许可证 - 查看 [LICENSE](LICENSE) 文件了解详情。

## 联系我们

- 项目主页: [GitHub Repository](https://github.com/username/offerHelper)
- 问题反馈: [Issues](https://github.com/username/offerHelper/issues)
- 邮箱: <support@example.com>

```

### 9.3 API 文档规范

```markdown
# API 文档

## IPC 通信接口

### 窗口控制

#### window:minimize

最小化窗口

**调用方式:**
```typescript
await window.electronAPI.window.minimize();
```

**参数:** 无

**返回值:** `Promise<void>`

**示例:**

```typescript
const handleMinimize = async () => {
  try {
    await window.electronAPI.window.minimize();
    console.log('窗口已最小化');
  } catch (error) {
    console.error('最小化失败:', error);
  }
};
```

#### window:setOpacity

设置窗口透明度

**调用方式:**

```typescript
await window.electronAPI.window.setOpacity(opacity);
```

**参数:**

- `opacity` (number): 透明度值，范围 0-1

**返回值:** `Promise<void>`

**异常:**

- `InvalidArgumentError`: 当透明度值超出范围时抛出

**示例:**

```typescript
// 设置50%透明度
await window.electronAPI.window.setOpacity(0.5);
```

### 语音控制

#### voice:start

开始语音识别

**调用方式:**

```typescript
await window.electronAPI.voice.start();
```

**参数:** 无

**返回值:** `Promise<void>`

**异常:**

- `PermissionError`: 麦克风权限被拒绝
- `DeviceError`: 麦克风设备不可用

**事件:**

- `voice:result`: 识别结果事件
- `voice:error`: 识别错误事件

**示例:**

```typescript
// 开始语音识别
await window.electronAPI.voice.start();

// 监听识别结果
window.electronAPI.voice.onResult((text) => {
  console.log('识别结果:', text);
});
```

```

## 10. 部署规范

### 10.1 环境配置

```bash
# 生产环境变量
NODE_ENV=production
ELECTRON_IS_DEV=false

# API 配置
AI_API_BASE_URL=https://api.zhipuai.cn
AI_API_KEY=your_api_key_here

# 语音识别配置
TENCENT_ASR_SECRET_ID=your_secret_id
TENCENT_ASR_SECRET_KEY=your_secret_key

# 更新服务配置
AUTO_UPDATE_URL=https://update.example.com
UPDATE_CHECK_INTERVAL=3600000

# 日志配置
LOG_LEVEL=info
LOG_MAX_SIZE=10485760
LOG_MAX_FILES=5

# 安全配置
ENCRYPTION_KEY=your_encryption_key_here
CSP_REPORT_URI=https://csp-report.example.com
```

### 10.2 构建配置

```json
{
  "build": {
    "appId": "com.company.offerHelper",
    "productName": "AI面试助手",
    "directories": {
      "output": "dist"
    },
    "files": [
      "build/**/*",
      "node_modules/**/*",
      "package.json"
    ],
    "mac": {
      "category": "public.app-category.productivity",
      "hardenedRuntime": true,
      "entitlements": "build/entitlements.mac.plist",
      "entitlementsInherit": "build/entitlements.mac.plist"
    },
    "win": {
      "target": "nsis",
      "certificateFile": "build/certificate.p12",
      "certificatePassword": "${env.CERTIFICATE_PASSWORD}"
    },
    "publish": {
      "provider": "github",
      "owner": "username",
      "repo": "offerHelper"
    }
  }
}
```

### 10.3 CI/CD 配置

```yaml
# .github/workflows/build.yml
name: Build and Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test

    - name: Build application
      run: npm run build

    - name: Package application
      run: npm run dist
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: ${{ matrix.os }}-build
        path: dist/
```

这个开发规范文档涵盖了AI面试助手桌面端项目的完整开发标准，包括代码规范、测试规范、安全规范、文档规范和部署规范等各个方面，为团队协作和项目维护提供了统一的标准。
