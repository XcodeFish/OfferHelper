# 桌面端隐私保护设计方案

## 1. 项目背景

### 1.1 需求描述

开发桌面端面试辅助工具，在用户进行视频面试并开启屏幕共享时，确保面试辅助工具对面试官完全不可见，保护用户隐私的同时提供有效的面试辅助功能。

### 1.2 核心挑战

- 屏幕共享时隐藏应用窗口
- 保持功能正常运行
- 跨平台兼容性
- 用户体验优化

## 2. 技术实现方案

### 2.1 窗口隐私保护技术

#### 2.1.1 Electron 窗口属性配置

```javascript
const mainWindow = new BrowserWindow({
  width: 400,
  height: 600,
  skipTaskbar: true,        // 不在任务栏显示
  alwaysOnTop: true,        // 始终置顶
  frame: false,             // 无边框窗口
  transparent: true,        // 透明背景
  resizable: false,         // 禁止调整大小
  minimizable: false,       // 禁止最小化
  maximizable: false,       // 禁止最大化
  webPreferences: {
    nodeIntegration: true,
    contextIsolation: false,
    webSecurity: false
  }
});

// 设置窗口内容保护
mainWindow.setContentProtection(true);
```

#### 2.1.2 系统级窗口保护

**Windows 平台**

```javascript
const { ffi, ref } = require('ffi-napi');
const user32 = ffi.Library('user32', {
  'SetWindowDisplayAffinity': ['bool', ['pointer', 'uint32']]
});

// WDA_EXCLUDEFROMCAPTURE = 0x00000011
const WDA_EXCLUDEFROMCAPTURE = 0x11;
const hwnd = mainWindow.getNativeWindowHandle();
user32.SetWindowDisplayAffinity(hwnd, WDA_EXCLUDEFROMCAPTURE);
```

**macOS 平台**

```javascript
const { app } = require('electron');

app.whenReady().then(() => {
  // 设置窗口共享类型为不可共享
  mainWindow.setContentProtection(true);

  // 使用 Objective-C 桥接
  const { execSync } = require('child_process');
  const windowId = mainWindow.id;
  execSync(`osascript -e 'tell application "System Events" to set sharing type of window ${windowId} to none'`);
});
```

**Linux 平台**

```javascript
// 使用 X11 窗口属性
const { execSync } = require('child_process');
const windowId = mainWindow.getNativeWindowHandle();
execSync(`xprop -id ${windowId} -f _NET_WM_BYPASS_COMPOSITOR 32c -set _NET_WM_BYPASS_COMPOSITOR 2`);
```

### 2.2 智能检测与隐藏机制

#### 2.2.1 屏幕共享检测

```javascript
const { desktopCapturer, screen } = require('electron');

class ScreenSharingDetector {
  constructor() {
    this.isMonitoring = false;
    this.checkInterval = null;
  }

  async startMonitoring() {
    this.isMonitoring = true;
    this.checkInterval = setInterval(async () => {
      await this.checkScreenSharing();
    }, 1000);
  }

  async checkScreenSharing() {
    try {
      const sources = await desktopCapturer.getSources({
        types: ['screen', 'window'],
        thumbnailSize: { width: 1, height: 1 }
      });

      // 检测是否有应用正在捕获屏幕
      const isSharing = await this.detectActiveCapture();

      if (isSharing && mainWindow.isVisible()) {
        this.hideAssistant();
      } else if (!isSharing && !mainWindow.isVisible()) {
        this.showAssistant();
      }
    } catch (error) {
      console.error('屏幕共享检测失败:', error);
    }
  }

  async detectActiveCapture() {
    // 检测常见视频会议软件进程
    const videoApps = [
      'zoom.exe', 'Teams.exe', 'Skype.exe',
      'chrome.exe', 'firefox.exe', 'safari'
    ];

    // 使用系统 API 检测进程状态
    return await this.checkProcesses(videoApps);
  }

  hideAssistant() {
    mainWindow.hide();
    // 显示系统托盘提示
    tray.displayBalloon({
      title: 'OfferHelper',
      content: '检测到屏幕共享，助手已自动隐藏'
    });
  }

  showAssistant() {
    mainWindow.show();
  }
}
```

### 2.3 用户控制机制

#### 2.3.1 快捷键控制

```javascript
const { globalShortcut } = require('electron');

// 注册全局快捷键
app.whenReady().then(() => {
  // 快速隐藏/显示
  globalShortcut.register('CommandOrControl+Shift+H', () => {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
    }
  });

  // 紧急隐藏（双击 Ctrl）
  globalShortcut.register('CommandOrControl+CommandOrControl', () => {
    mainWindow.hide();
    setTimeout(() => {
      mainWindow.show();
    }, 5000); // 5秒后自动显示
  });
});
```

#### 2.3.2 鼠标手势控制

```javascript
class MouseGestureController {
  constructor() {
    this.lastPosition = { x: 0, y: 0 };
    this.gestureSequence = [];
  }

  startListening() {
    // 监听鼠标移动到屏幕边缘
    screen.on('display-metrics-changed', () => {
      const cursor = screen.getCursorScreenPoint();
      const displays = screen.getAllDisplays();

      // 检测鼠标是否移动到屏幕右上角
      if (this.isInCorner(cursor, displays)) {
        this.toggleAssistant();
      }
    });
  }

  isInCorner(cursor, displays) {
    const primaryDisplay = displays[0];
    const { width, height } = primaryDisplay.size;

    return (
      cursor.x >= width - 50 &&
      cursor.y <= 50
    );
  }

  toggleAssistant() {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
    }
  }
}
```

## 3. 界面设计方案

### 3.1 悬浮窗口设计

#### 3.1.1 窗口样式

```css
/* 主窗口样式 */
.assistant-window {
  background: rgba(0, 0, 0, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

/* 可拖拽区域 */
.drag-area {
  -webkit-app-region: drag;
  height: 30px;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  border-radius: 12px 12px 0 0;
}

/* 内容区域 */
.content-area {
  -webkit-app-region: no-drag;
  padding: 16px;
  max-height: 500px;
  overflow-y: auto;
}
```

#### 3.1.2 透明度控制

```javascript
class TransparencyController {
  constructor() {
    this.opacity = 0.9;
    this.isHovering = false;
  }

  setupOpacityControl() {
    // 鼠标悬停时增加不透明度
    mainWindow.on('mouse-enter', () => {
      this.isHovering = true;
      mainWindow.setOpacity(1.0);
    });

    // 鼠标离开时降低不透明度
    mainWindow.on('mouse-leave', () => {
      this.isHovering = false;
      setTimeout(() => {
        if (!this.isHovering) {
          mainWindow.setOpacity(this.opacity);
        }
      }, 2000);
    });
  }

  setOpacity(value) {
    this.opacity = Math.max(0.1, Math.min(1.0, value));
    if (!this.isHovering) {
      mainWindow.setOpacity(this.opacity);
    }
  }
}
```

### 3.2 用户界面组件

#### 3.2.1 状态指示器

```jsx
const StatusIndicator = () => {
  const [status, setStatus] = useState('normal'); // normal, hidden, sharing

  return (
    <div className="status-indicator">
      <div className={`status-dot ${status}`}>
        {status === 'normal' && <CheckCircle />}
        {status === 'hidden' && <EyeOff />}
        {status === 'sharing' && <Monitor />}
      </div>
      <span className="status-text">
        {status === 'normal' && '正常运行'}
        {status === 'hidden' && '已隐藏'}
        {status === 'sharing' && '屏幕共享中'}
      </span>
    </div>
  );
};
```

#### 3.2.2 快速操作面板

```jsx
const QuickActions = () => {
  return (
    <div className="quick-actions">
      <button onClick={toggleVisibility} className="action-btn">
        <Eye size={16} />
        切换显示
      </button>
      <button onClick={openSettings} className="action-btn">
        <Settings size={16} />
        设置
      </button>
      <button onClick={emergencyHide} className="action-btn danger">
        <AlertTriangle size={16} />
        紧急隐藏
      </button>
    </div>
  );
};
```

## 4. 安全性考虑

### 4.1 进程保护

```javascript
// 防止进程被轻易终止
process.on('SIGTERM', () => {
  // 保存用户数据
  saveUserData();
  // 延迟退出
  setTimeout(() => {
    app.quit();
  }, 1000);
});

// 防止调试器附加
if (process.env.NODE_ENV === 'production') {
  setInterval(() => {
    if (process.debugPort) {
      app.quit();
    }
  }, 1000);
}
```

### 4.2 数据加密

```javascript
const crypto = require('crypto');

class DataEncryption {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.key = crypto.scryptSync(process.env.ENCRYPTION_KEY || 'default-key', 'salt', 32);
  }

  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }

  decrypt(encryptedData) {
    const decipher = crypto.createDecipher(
      this.algorithm,
      this.key,
      Buffer.from(encryptedData.iv, 'hex')
    );

    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

## 5. 性能优化

### 5.1 资源管理

```javascript
class ResourceManager {
  constructor() {
    this.memoryThreshold = 100 * 1024 * 1024; // 100MB
    this.checkInterval = 30000; // 30秒
  }

  startMonitoring() {
    setInterval(() => {
      const memUsage = process.memoryUsage();

      if (memUsage.heapUsed > this.memoryThreshold) {
        this.optimizeMemory();
      }
    }, this.checkInterval);
  }

  optimizeMemory() {
    // 清理缓存
    global.gc && global.gc();

    // 清理未使用的组件
    this.cleanupComponents();

    // 压缩数据
    this.compressData();
  }
}
```

### 5.2 渲染优化

```javascript
// 使用虚拟化列表
const VirtualizedList = ({ items }) => {
  const [visibleItems, setVisibleItems] = useState([]);

  useEffect(() => {
    // 只渲染可见区域的项目
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + visibleCount,
      items.length
    );

    setVisibleItems(items.slice(startIndex, endIndex));
  }, [scrollTop, items]);

  return (
    <div className="virtual-list">
      {visibleItems.map(item => (
        <ListItem key={item.id} data={item} />
      ))}
    </div>
  );
};
```

## 6. 测试方案

### 6.1 隐私保护测试

```javascript
describe('隐私保护功能测试', () => {
  test('屏幕共享时窗口应该隐藏', async () => {
    // 模拟屏幕共享
    await simulateScreenSharing();

    // 检查窗口是否隐藏
    expect(mainWindow.isVisible()).toBe(false);
  });

  test('停止屏幕共享时窗口应该显示', async () => {
    // 停止屏幕共享
    await stopScreenSharing();

    // 检查窗口是否显示
    expect(mainWindow.isVisible()).toBe(true);
  });

  test('快捷键应该能够控制窗口显示', async () => {
    // 发送快捷键
    await sendShortcut('CommandOrControl+Shift+H');

    // 检查窗口状态变化
    expect(mainWindow.isVisible()).toBe(!previousState);
  });
});
```

### 6.2 跨平台兼容性测试

```javascript
describe('跨平台兼容性测试', () => {
  const platforms = ['win32', 'darwin', 'linux'];

  platforms.forEach(platform => {
    test(`${platform} 平台窗口保护功能`, async () => {
      // 模拟平台环境
      Object.defineProperty(process, 'platform', {
        value: platform
      });

      // 测试窗口保护功能
      const result = await testWindowProtection();
      expect(result).toBe(true);
    });
  });
});
```

## 7. 部署方案

### 7.1 打包配置

```json
{
  "build": {
    "appId": "com.offerhelper.desktop",
    "productName": "OfferHelper",
    "directories": {
      "output": "dist"
    },
    "files": [
      "build/**/*",
      "node_modules/**/*",
      "package.json"
    ],
    "mac": {
      "category": "public.app-category.productivity",
      "hardenedRuntime": true,
      "entitlements": "build/entitlements.mac.plist"
    },
    "win": {
      "target": "nsis",
      "requestedExecutionLevel": "asInvoker"
    },
    "linux": {
      "target": "AppImage",
      "category": "Office"
    }
  }
}
```

### 7.2 自动更新

```javascript
const { autoUpdater } = require('electron-updater');

class AutoUpdater {
  constructor() {
    autoUpdater.checkForUpdatesAndNotify();
  }

  setupUpdateHandlers() {
    autoUpdater.on('update-available', () => {
      // 通知用户有更新
      this.notifyUpdate();
    });

    autoUpdater.on('update-downloaded', () => {
      // 提示用户重启应用
      this.promptRestart();
    });
  }

  notifyUpdate() {
    const response = dialog.showMessageBoxSync(mainWindow, {
      type: 'info',
      buttons: ['立即更新', '稍后更新'],
      title: '发现新版本',
      message: '发现新版本，是否立即更新？'
    });

    if (response === 0) {
      autoUpdater.downloadUpdate();
    }
  }
}
```

## 8. 总结

本设计方案通过多层次的技术手段确保桌面端面试辅助工具在屏幕共享时完全隐藏，同时保持功能的完整性和用户体验的流畅性。主要特点包括：

1. **多平台兼容**：支持 Windows、macOS、Linux 三大平台
2. **智能检测**：自动检测屏幕共享状态并响应
3. **用户控制**：提供多种手动控制方式
4. **安全可靠**：数据加密和进程保护
5. **性能优化**：资源管理和渲染优化
6. **易于维护**：模块化设计和完整测试

该方案能够有效解决面试辅助工具的隐私保护需求，为用户提供安全、可靠的面试辅助服务。
