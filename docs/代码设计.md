# AI面试助手桌面端代码设计

## 1. 设计模式应用

### 1.1 单例模式 (Singleton Pattern)

```typescript
// src/main/services/WindowManager.ts
export class WindowManager {
  private static instance: WindowManager;
  private mainWindow: BrowserWindow | null = null;
  private loginWindow: BrowserWindow | null = null;
  private settingsWindow: BrowserWindow | null = null;

  private constructor() {}

  public static getInstance(): WindowManager {
    if (!WindowManager.instance) {
      WindowManager.instance = new WindowManager();
    }
    return WindowManager.instance;
  }

  public async createMainWindow(): Promise<BrowserWindow> {
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      this.mainWindow.focus();
      return this.mainWindow;
    }

    this.mainWindow = new BrowserWindow({
      width: 400,
      height: 340,
      frame: false,
      transparent: true,
      alwaysOnTop: true,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, '../preload/index.js'),
      },
    });

    await this.mainWindow.loadFile('build/renderer/index.html');
    return this.mainWindow;
  }

  public getMainWindow(): BrowserWindow | null {
    return this.mainWindow;
  }

  public closeAllWindows(): void {
    [this.mainWindow, this.loginWindow, this.settingsWindow].forEach(window => {
      if (window && !window.isDestroyed()) {
        window.close();
      }
    });
  }
}
```

### 1.2 观察者模式 (Observer Pattern)

```typescript
// src/shared/utils/EventEmitter.ts
export class EventEmitter<T extends Record<string, any>> {
  private listeners: Map<keyof T, Set<Function>> = new Map();

  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(listener);
  }

  off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.delete(listener);
    }
  }

  emit<K extends keyof T>(event: K, data: T[K]): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach(listener => listener(data));
    }
  }

  removeAllListeners<K extends keyof T>(event?: K): void {
    if (event) {
      this.listeners.delete(event);
    } else {
      this.listeners.clear();
    }
  }
}

// 使用示例
interface VoiceEvents {
  'recognition:start': void;
  'recognition:result': string;
  'recognition:error': Error;
  'recognition:end': void;
}

export class VoiceRecognitionService extends EventEmitter<VoiceEvents> {
  private recognition: SpeechRecognition | null = null;

  async startRecognition(): Promise<void> {
    this.emit('recognition:start', undefined);

    try {
      // 语音识别逻辑
      const result = await this.performRecognition();
      this.emit('recognition:result', result);
    } catch (error) {
      this.emit('recognition:error', error as Error);
    } finally {
      this.emit('recognition:end', undefined);
    }
  }

  private async performRecognition(): Promise<string> {
    // 实现语音识别逻辑
    return 'recognized text';
  }
}
```

### 1.3 策略模式 (Strategy Pattern)

```typescript
// src/renderer/services/ai/strategies/AIStrategy.ts
export interface AIStrategy {
  generateResponse(text: string, mode: ResponseMode): Promise<string>;
  validateApiKey(): boolean;
  getProviderName(): string;
}

// 智谱AI策略
export class ZhipuAIStrategy implements AIStrategy {
  constructor(private apiKey: string) {}

  async generateResponse(text: string, mode: ResponseMode): Promise<string> {
    const response = await fetch('https://api.zhipuai.cn/chat', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'glm-4',
        messages: [{ role: 'user', content: text }],
        temperature: this.getTemperatureByMode(mode),
      }),
    });

    const data = await response.json();
    return data.choices[0].message.content;
  }

  validateApiKey(): boolean {
    return this.apiKey && this.apiKey.length > 0;
  }

  getProviderName(): string {
    return '智谱AI';
  }

  private getTemperatureByMode(mode: ResponseMode): number {
    switch (mode) {
      case 'simple': return 0.3;
      case 'normal': return 0.7;
      case 'detailed': return 0.9;
      default: return 0.7;
    }
  }
}

// OpenAI策略
export class OpenAIStrategy implements AIStrategy {
  constructor(private apiKey: string) {}

  async generateResponse(text: string, mode: ResponseMode): Promise<string> {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: text }],
        max_tokens: this.getMaxTokensByMode(mode),
      }),
    });

    const data = await response.json();
    return data.choices[0].message.content;
  }

  validateApiKey(): boolean {
    return this.apiKey && this.apiKey.startsWith('sk-');
  }

  getProviderName(): string {
    return 'OpenAI';
  }

  private getMaxTokensByMode(mode: ResponseMode): number {
    switch (mode) {
      case 'simple': return 100;
      case 'normal': return 300;
      case 'detailed': return 500;
      default: return 300;
    }
  }
}

// AI服务上下文
export class AIService {
  private strategy: AIStrategy;

  constructor(strategy: AIStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: AIStrategy): void {
    this.strategy = strategy;
  }

  async getResponse(text: string, mode: ResponseMode): Promise<string> {
    if (!this.strategy.validateApiKey()) {
      throw new Error(`${this.strategy.getProviderName()} API密钥无效`);
    }

    return await this.strategy.generateResponse(text, mode);
  }

  getProviderName(): string {
    return this.strategy.getProviderName();
  }
}
```

### 1.4 工厂模式 (Factory Pattern)

```typescript
// src/renderer/services/ServiceFactory.ts
export abstract class ServiceFactory {
  abstract createVoiceService(): VoiceService;
  abstract createAIService(): AIService;
  abstract createStorageService(): StorageService;
}

export class ProductionServiceFactory extends ServiceFactory {
  createVoiceService(): VoiceService {
    return new TencentVoiceService({
      secretId: process.env.TENCENT_SECRET_ID!,
      secretKey: process.env.TENCENT_SECRET_KEY!,
      region: 'ap-beijing',
    });
  }

  createAIService(): AIService {
    const strategy = new ZhipuAIStrategy(process.env.ZHIPU_API_KEY!);
    return new AIService(strategy);
  }

  createStorageService(): StorageService {
    return new ElectronStorageService();
  }
}

export class DevelopmentServiceFactory extends ServiceFactory {
  createVoiceService(): VoiceService {
    return new MockVoiceService();
  }

  createAIService(): AIService {
    const strategy = new MockAIStrategy();
    return new AIService(strategy);
  }

  createStorageService(): StorageService {
    return new MemoryStorageService();
  }
}

export class TestServiceFactory extends ServiceFactory {
  createVoiceService(): VoiceService {
    return new MockVoiceService();
  }

  createAIService(): AIService {
    const strategy = new MockAIStrategy();
    return new AIService(strategy);
  }

  createStorageService(): StorageService {
    return new MemoryStorageService();
  }
}

// 工厂选择器
export class ServiceFactoryProvider {
  static getFactory(): ServiceFactory {
    switch (process.env.NODE_ENV) {
      case 'production':
        return new ProductionServiceFactory();
      case 'development':
        return new DevelopmentServiceFactory();
      case 'test':
        return new TestServiceFactory();
      default:
        return new DevelopmentServiceFactory();
    }
  }
}
```

### 1.5 装饰器模式 (Decorator Pattern)

```typescript
// src/renderer/services/decorators/ServiceDecorator.ts
export interface Service {
  execute(input: any): Promise<any>;
}

// 基础装饰器
export abstract class ServiceDecorator implements Service {
  constructor(protected service: Service) {}

  async execute(input: any): Promise<any> {
    return await this.service.execute(input);
  }
}

// 日志装饰器
export class LoggingDecorator extends ServiceDecorator {
  constructor(service: Service, private logger: Logger) {
    super(service);
  }

  async execute(input: any): Promise<any> {
    const startTime = Date.now();
    this.logger.info('服务调用开始', { input, timestamp: startTime });

    try {
      const result = await super.execute(input);
      const endTime = Date.now();
      this.logger.info('服务调用成功', {
        input,
        result,
        duration: endTime - startTime,
        timestamp: endTime,
      });
      return result;
    } catch (error) {
      const endTime = Date.now();
      this.logger.error('服务调用失败', {
        input,
        error: error instanceof Error ? error.message : String(error),
        duration: endTime - startTime,
        timestamp: endTime,
      });
      throw error;
    }
  }
}

// 缓存装饰器
export class CachingDecorator extends ServiceDecorator {
  private cache = new Map<string, { data: any; timestamp: number }>();
  private ttl: number;

  constructor(service: Service, ttlMs: number = 300000) { // 5分钟默认TTL
    super(service);
    this.ttl = ttlMs;
  }

  async execute(input: any): Promise<any> {
    const cacheKey = this.generateCacheKey(input);
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data;
    }

    const result = await super.execute(input);
    this.cache.set(cacheKey, { data: result, timestamp: Date.now() });
    return result;
  }

  private generateCacheKey(input: any): string {
    return JSON.stringify(input);
  }

  clearCache(): void {
    this.cache.clear();
  }
}

// 重试装饰器
export class RetryDecorator extends ServiceDecorator {
  constructor(
    service: Service,
    private maxRetries: number = 3,
    private retryDelay: number = 1000
  ) {
    super(service);
  }

  async execute(input: any): Promise<any> {
    let lastError: Error;

    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await super.execute(input);
      } catch (error) {
        lastError = error as Error;

        if (attempt < this.maxRetries) {
          await this.delay(this.retryDelay * Math.pow(2, attempt)); // 指数退避
        }
      }
    }

    throw lastError!;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// 使用示例
const baseAIService = new AIService(new ZhipuAIStrategy(apiKey));
const decoratedService = new LoggingDecorator(
  new CachingDecorator(
    new RetryDecorator(baseAIService, 3, 1000),
    300000
  ),
  logger
);
```

## 2. 架构设计模式

### 2.1 分层架构 (Layered Architecture)

```typescript
// 表现层 (Presentation Layer)
// src/renderer/components/VoiceRecorder/index.tsx
export const VoiceRecorder: React.FC<VoiceRecorderProps> = ({
  onResult,
  onError
}) => {
  const { startRecording, stopRecording, isRecording } = useVoiceRecording({
    onResult,
    onError
  });

  return (
    <Container>
      <RecordButton
        onClick={isRecording ? stopRecording : startRecording}
        $isRecording={isRecording}
      >
        {isRecording ? '停止' : '开始'}
      </RecordButton>
    </Container>
  );
};

// 业务逻辑层 (Business Logic Layer)
// src/renderer/hooks/useVoiceRecording.ts
export const useVoiceRecording = ({ onResult, onError }: UseVoiceRecordingProps) => {
  const [isRecording, setIsRecording] = useState(false);
  const voiceService = useVoiceService();

  const startRecording = useCallback(async () => {
    try {
      await voiceService.startRecognition();
      setIsRecording(true);
    } catch (error) {
      onError?.(error as Error);
    }
  }, [voiceService, onError]);

  const stopRecording = useCallback(async () => {
    try {
      await voiceService.stopRecognition();
      setIsRecording(false);
    } catch (error) {
      onError?.(error as Error);
    }
  }, [voiceService, onError]);

  useEffect(() => {
    const handleResult = (text: string) => {
      onResult?.(text);
    };

    voiceService.on('recognition:result', handleResult);
    return () => voiceService.off('recognition:result', handleResult);
  }, [voiceService, onResult]);

  return { startRecording, stopRecording, isRecording };
};

// 服务层 (Service Layer)
// src/renderer/services/VoiceService.ts
export class VoiceService extends EventEmitter<VoiceEvents> {
  private recognition: SpeechRecognition | null = null;
  private isRecording = false;

  async startRecognition(): Promise<void> {
    if (this.isRecording) return;

    try {
      await this.initializeRecognition();
      this.recognition!.start();
      this.isRecording = true;
      this.emit('recognition:start', undefined);
    } catch (error) {
      this.emit('recognition:error', error as Error);
      throw error;
    }
  }

  async stopRecognition(): Promise<void> {
    if (!this.isRecording || !this.recognition) return;

    this.recognition.stop();
    this.isRecording = false;
    this.emit('recognition:end', undefined);
  }

  private async initializeRecognition(): Promise<void> {
    // 初始化语音识别逻辑
  }
}

// 数据访问层 (Data Access Layer)
// src/renderer/services/StorageService.ts
export interface StorageService {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
}

export class ElectronStorageService implements StorageService {
  async get<T>(key: string): Promise<T | null> {
    return await window.electronAPI.storage.get(key);
  }

  async set<T>(key: string, value: T): Promise<void> {
    await window.electronAPI.storage.set(key, value);
  }

  async remove(key: string): Promise<void> {
    await window.electronAPI.storage.remove(key);
  }

  async clear(): Promise<void> {
    await window.electronAPI.storage.clear();
  }
}
```

### 2.2 MVC 模式 (Model-View-Controller)

```typescript
// Model - 数据模型
// src/renderer/models/VoiceRecognitionModel.ts
export class VoiceRecognitionModel {
  private _isRecording = false;
  private _lastResult = '';
  private _volume = 0;
  private _error: Error | null = null;

  // Getters
  get isRecording(): boolean { return this._isRecording; }
  get lastResult(): string { return this._lastResult; }
  get volume(): number { return this._volume; }
  get error(): Error | null { return this._error; }

  // Setters with validation
  setRecording(isRecording: boolean): void {
    this._isRecording = isRecording;
    if (!isRecording) {
      this._volume = 0;
    }
  }

  setResult(result: string): void {
    if (typeof result !== 'string') {
      throw new Error('Result must be a string');
    }
    this._lastResult = result;
    this._error = null; // Clear error on successful result
  }

  setVolume(volume: number): void {
    if (volume < 0 || volume > 100) {
      throw new Error('Volume must be between 0 and 100');
    }
    this._volume = volume;
  }

  setError(error: Error): void {
    this._error = error;
  }

  reset(): void {
    this._isRecording = false;
    this._lastResult = '';
    this._volume = 0;
    this._error = null;
  }

  toJSON() {
    return {
      isRecording: this._isRecording,
      lastResult: this._lastResult,
      volume: this._volume,
      error: this._error?.message || null,
    };
  }
}

// View - React组件
// src/renderer/components/VoiceRecorder/VoiceRecorderView.tsx
interface VoiceRecorderViewProps {
  model: VoiceRecognitionModel;
  onStartRecording: () => void;
  onStopRecording: () => void;
  onClearResult: () => void;
}

export const VoiceRecorderView: React.FC<VoiceRecorderViewProps> = ({
  model,
  onStartRecording,
  onStopRecording,
  onClearResult
}) => {
  return (
    <Container>
      <StatusDisplay>
        {model.isRecording ? '正在录音...' : '点击开始录音'}
      </StatusDisplay>

      <VolumeIndicator volume={model.volume} />

      <ControlButtons>
        <RecordButton
          onClick={model.isRecording ? onStopRecording : onStartRecording}
          $isRecording={model.isRecording}
        >
          {model.isRecording ? '停止' : '开始'}
        </RecordButton>

        <ClearButton onClick={onClearResult} disabled={!model.lastResult}>
          清除
        </ClearButton>
      </ControlButtons>

      {model.lastResult && (
        <ResultDisplay>
          <ResultText>{model.lastResult}</ResultText>
        </ResultDisplay>
      )}

      {model.error && (
        <ErrorDisplay>
          <ErrorText>{model.error.message}</ErrorText>
        </ErrorDisplay>
      )}
    </Container>
  );
};

// Controller - 控制器
// src/renderer/controllers/VoiceRecorderController.ts
export class VoiceRecorderController {
  private model: VoiceRecognitionModel;
  private voiceService: VoiceService;
  private view: React.ComponentType<VoiceRecorderViewProps>;

  constructor(
    model: VoiceRecognitionModel,
    voiceService: VoiceService,
    view: React.ComponentType<VoiceRecorderViewProps>
  ) {
    this.model = model;
    this.voiceService = voiceService;
    this.view = view;
    this.setupEventListeners();
  }

  async startRecording(): Promise<void> {
    try {
      await this.voiceService.startRecognition();
      this.model.setRecording(true);
    } catch (error) {
      this.model.setError(error as Error);
    }
  }

  async stopRecording(): Promise<void> {
    try {
      await this.voiceService.stopRecognition();
      this.model.setRecording(false);
    } catch (error) {
      this.model.setError(error as Error);
    }
  }

  clearResult(): void {
    this.model.setResult('');
  }

  private setupEventListeners(): void {
    this.voiceService.on('recognition:result', (result: string) => {
      this.model.setResult(result);
    });

    this.voiceService.on('recognition:error', (error: Error) => {
      this.model.setError(error);
      this.model.setRecording(false);
    });

    this.voiceService.on('volume:change', (volume: number) => {
      this.model.setVolume(volume);
    });
  }

  getView(): React.ComponentType<VoiceRecorderViewProps> {
    return this.view;
  }

  getModel(): VoiceRecognitionModel {
    return this.model;
  }
}

// 使用示例
const useVoiceRecorderController = () => {
  const model = useMemo(() => new VoiceRecognitionModel(), []);
  const voiceService = useVoiceService();

  const controller = useMemo(() =>
    new VoiceRecorderController(model, voiceService, VoiceRecorderView),
    [model, voiceService]
  );

  return controller;
};
```

### 2.3 MVVM 模式 (Model-View-ViewModel)

```typescript
// Model - 数据模型 (同上)

// ViewModel - 视图模型
// src/renderer/viewmodels/VoiceRecorderViewModel.ts
export class VoiceRecorderViewModel {
  private model: VoiceRecognitionModel;
  private voiceService: VoiceService;
  private eventEmitter = new EventEmitter<ViewModelEvents>();

  constructor(model: VoiceRecognitionModel, voiceService: VoiceService) {
    this.model = model;
    this.voiceService = voiceService;
    this.setupServiceListeners();
  }

  // 计算属性
  get displayText(): string {
    if (this.model.error) {
      return `错误: ${this.model.error.message}`;
    }
    if (this.model.isRecording) {
      return '正在录音...';
    }
    return this.model.lastResult || '点击开始录音';
  }

  get buttonText(): string {
    return this.model.isRecording ? '停止' : '开始';
  }

  get canClear(): boolean {
    return !!this.model.lastResult && !this.model.isRecording;
  }

  get volumePercentage(): string {
    return `${this.model.volume}%`;
  }

  // 命令方法
  async toggleRecording(): Promise<void> {
    if (this.model.isRecording) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }

  async startRecording(): Promise<void> {
    try {
      await this.voiceService.startRecognition();
      this.model.setRecording(true);
      this.notifyViewUpdate();
    } catch (error) {
      this.model.setError(error as Error);
      this.notifyViewUpdate();
    }
  }

  async stopRecording(): Promise<void> {
    try {
      await this.voiceService.stopRecognition();
      this.model.setRecording(false);
      this.notifyViewUpdate();
    } catch (error) {
      this.model.setError(error as Error);
      this.notifyViewUpdate();
    }
  }

  clearResult(): void {
    this.model.setResult('');
    this.notifyViewUpdate();
  }

  // 事件订阅
  onViewUpdate(callback: () => void): () => void {
    this.eventEmitter.on('viewUpdate', callback);
    return () => this.eventEmitter.off('viewUpdate', callback);
  }

  private setupServiceListeners(): void {
    this.voiceService.on('recognition:result', (result: string) => {
      this.model.setResult(result);
      this.notifyViewUpdate();
    });

    this.voiceService.on('recognition:error', (error: Error) => {
      this.model.setError(error);
      this.model.setRecording(false);
      this.notifyViewUpdate();
    });

    this.voiceService.on('volume:change', (volume: number) => {
      this.model.setVolume(volume);
      this.notifyViewUpdate();
    });
  }

  private notifyViewUpdate(): void {
    this.eventEmitter.emit('viewUpdate', undefined);
  }

  dispose(): void {
    this.eventEmitter.removeAllListeners();
  }
}

// View - React组件 (使用ViewModel)
// src/renderer/components/VoiceRecorder/VoiceRecorderMVVM.tsx
export const VoiceRecorderMVVM: React.FC = () => {
  const model = useMemo(() => new VoiceRecognitionModel(), []);
  const voiceService = useVoiceService();
  const viewModel = useMemo(() =>
    new VoiceRecorderViewModel(model, voiceService),
    [model, voiceService]
  );

  const [, forceUpdate] = useReducer(x => x + 1, 0);

  useEffect(() => {
    const unsubscribe = viewModel.onViewUpdate(() => {
      forceUpdate();
    });

    return () => {
      unsubscribe();
      viewModel.dispose();
    };
  }, [viewModel]);

  return (
    <Container>
      <StatusDisplay>{viewModel.displayText}</StatusDisplay>

      <VolumeIndicator volume={model.volume} />

      <ControlButtons>
        <RecordButton
          onClick={viewModel.toggleRecording}
          $isRecording={model.isRecording}
        >
          {viewModel.buttonText}
        </RecordButton>

        <ClearButton
          onClick={viewModel.clearResult}
          disabled={!viewModel.canClear}
        >
          清除
        </ClearButton>
      </ControlButtons>

      {model.lastResult && (
        <ResultDisplay>
          <ResultText>{model.lastResult}</ResultText>
        </ResultDisplay>
      )}
    </Container>
  );
};
```

## 3. 数据流设计

### 3.1 Redux 数据流

```typescript
// src/renderer/store/slices/voiceSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';

// 异步操作
export const startVoiceRecognition = createAsyncThunk(
  'voice/startRecognition',
  async (_, { dispatch, rejectWithValue }) => {
    try {
      const voiceService = ServiceFactoryProvider.getFactory().createVoiceService();
      await voiceService.startRecognition();
      return true;
    } catch (error) {
      return rejectWithValue(error instanceof Error ? error.message : String(error));
    }
  }
);

export const stopVoiceRecognition = createAsyncThunk(
  'voice/stopRecognition',
  async (_, { dispatch, rejectWithValue }) => {
    try {
      const voiceService = ServiceFactoryProvider.getFactory().createVoiceService();
      await voiceService.stopRecognition();
      return true;
    } catch (error) {
      return rejectWithValue(error instanceof Error ? error.message : String(error));
    }
  }
);

// 状态接口
interface VoiceState {
  isRecording: boolean;
  volume: number;
  lastResult: string;
  error: string | null;
  isLoading: boolean;
}

const initialState: VoiceState = {
  isRecording: false,
  volume: 0,
  lastResult: '',
  error: null,
  isLoading: false,
};

// Slice定义
export const voiceSlice = createSlice({
  name: 'voice',
  initialState,
  reducers: {
    setVolume: (state, action: PayloadAction<number>) => {
      state.volume = Math.max(0, Math.min(100, action.payload));
    },
    setResult: (state, action: PayloadAction<string>) => {
      state.lastResult = action.payload;
      state.error = null;
    },
    clearResult: (state) => {
      state.lastResult = '';
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // 开始录音
      .addCase(startVoiceRecognition.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(startVoiceRecognition.fulfilled, (state) => {
        state.isRecording = true;
        state.isLoading = false;
      })
      .addCase(startVoiceRecognition.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // 停止录音
      .addCase(stopVoiceRecognition.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(stopVoiceRecognition.fulfilled, (state) => {
        state.isRecording = false;
        state.isLoading = false;
        state.volume = 0;
      })
      .addCase(stopVoiceRecognition.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  },
});

export const { setVolume, setResult, clearResult, clearError } = voiceSlice.actions;

// Selectors
export const selectVoiceState = (state: RootState) => state.voice;
export const selectIsRecording = (state: RootState) => state.voice.isRecording;
export const selectVoiceResult = (state: RootState) => state.voice.lastResult;
export const selectVoiceError = (state: RootState) => state.voice.error;
```

### 3.2 事件驱动架构

```typescript
// src/shared/events/EventBus.ts
export class EventBus {
  private static instance: EventBus;
  private listeners: Map<string, Set<Function>> = new Map();

  private constructor() {}

  static getInstance(): EventBus {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
    }
    return EventBus.instance;
  }

  subscribe<T = any>(event: string, listener: (data: T) => void): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(listener);

    // 返回取消订阅函数
    return () => {
      const eventListeners = this.listeners.get(event);
      if (eventListeners) {
        eventListeners.delete(listener);
        if (eventListeners.size === 0) {
          this.listeners.delete(event);
        }
      }
    };
  }

  publish<T = any>(event: string, data?: T): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach(listener => {
        try {
          listener(data);
        } catch (error) {
          console.error(`事件处理器执行失败 [${event}]:`, error);
        }
      });
    }
  }

  unsubscribe(event: string, listener?: Function): void {
    if (listener) {
      const eventListeners = this.listeners.get(event);
      if (eventListeners) {
        eventListeners.delete(listener);
      }
    } else {
      this.listeners.delete(event);
    }
  }

  clear(): void {
    this.listeners.clear();
  }

  getEventNames(): string[] {
    return Array.from(this.listeners.keys());
  }

  getListenerCount(event: string): number {
    return this.listeners.get(event)?.size || 0;
  }
}

// 事件定义
export const Events = {
  // 语音相关事件
  VOICE_RECOGNITION_STARTED: 'voice:recognition:started',
  VOICE_RECOGNITION_STOPPED: 'voice:recognition:stopped',
  VOICE_RECOGNITION_RESULT: 'voice:recognition:result',
  VOICE_RECOGNITION_ERROR: 'voice:recognition:error',
  VOICE_VOLUME_CHANGED: 'voice:volume:changed',

  // AI相关事件
  AI_RESPONSE_REQUESTED: 'ai:response:requested',
  AI_RESPONSE_RECEIVED: 'ai:response:received',
  AI_RESPONSE_ERROR: 'ai:response:error',

  // 窗口相关事件
  WINDOW_VISIBILITY_CHANGED: 'window:visibility:changed',
  WINDOW_OPACITY_CHANGED: 'window:opacity:changed',
  SCREEN_SHARE_DETECTED: 'screen:share:detected',

  // 设置相关事件
  SETTINGS_CHANGED: 'settings:changed',
  THEME_CHANGED: 'theme:changed',

  // 应用生命周期事件
  APP_READY: 'app:ready',
  APP_CLOSING: 'app:closing',
} as const;

// 使用示例
const eventBus = EventBus.getInstance();

// 订阅事件
const unsubscribe = eventBus.subscribe(Events.VOICE_RECOGNITION_RESULT, (text: string) => {
  console.log('语音识别结果:', text);
});

// 发布事件
eventBus.publish(Events.VOICE_RECOGNITION_RESULT, '你好世界');

// 取消订阅
unsubscribe();
```

## 4. 错误处理设计

### 4.1 错误类型定义

```typescript
// src/shared/errors/AppErrors.ts
export abstract class AppError extends Error {
  abstract readonly code: string;
  abstract readonly statusCode: number;

  constructor(message: string, public readonly context?: Record<string, any>) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      statusCode: this.statusCode,
      context: this.context,
      stack: this.stack,
    };
  }
}

// 网络错误
export class NetworkError extends AppError {
  readonly code = 'NETWORK_ERROR';
  readonly statusCode = 500;

  constructor(message: string, context?: Record<string, any>) {
    super(message, context);
  }
}

// 认证错误
export class AuthenticationError extends AppError {
  readonly code = 'AUTHENTICATION_ERROR';
  readonly statusCode = 401;

  constructor(message: string = '认证失败', context?: Record<string, any>) {
    super(message, context);
  }
}

// 权限错误
export class PermissionError extends AppError {
  readonly code = 'PERMISSION_ERROR';
  readonly statusCode = 403;

  constructor(message: string, context?: Record<string, any>) {
    super(message, context);
  }
}

// 验证错误
export class ValidationError extends AppError {
  readonly code = 'VALIDATION_ERROR';
  readonly statusCode = 400;

  constructor(message: string, public readonly field?: string, context?: Record<string, any>) {
    super(message, { ...context, field });
  }
}

// 语音识别错误
export class VoiceRecognitionError extends AppError {
  readonly code = 'VOICE_RECOGNITION_ERROR';
  readonly statusCode = 500;

  constructor(message: string, context?: Record<string, any>) {
    super(message, context);
  }
}

// AI服务错误
export class AIServiceError extends AppError {
  readonly code = 'AI_SERVICE_ERROR';
  readonly statusCode = 500;

  constructor(message: string, context?: Record<string, any>) {
    super(message, context);
  }
}

// 配置错误
export class ConfigurationError extends AppError {
  readonly code = 'CONFIGURATION_ERROR';
  readonly statusCode = 500;

  constructor(message: string, context?: Record<string, any>) {
    super(message, context);
  }
}
```

### 4.2 错误处理中间件

```typescript
// src/renderer/middleware/errorMiddleware.ts
import { Middleware } from '@reduxjs/toolkit';
import { AppError } from '@shared/errors/AppErrors';
import { logger } from '@shared/utils/logger';
import { EventBus, Events } from '@shared/events/EventBus';

export const errorMiddleware: Middleware = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    const appError = error instanceof AppError ? error : new AppError(
      error instanceof Error ? error.message : String(error),
      { originalError: error }
    );

    // 记录错误
    logger.error('Redux action 执行失败:', {
      action: action.type,
      error: appError.toJSON(),
    });

    // 发布错误事件
    EventBus.getInstance().publish('app:error', appError);

    // 根据错误类型进行不同处理
    handleError(appError);

    throw appError;
  }
};

function handleError(error: AppError): void {
  switch (error.code) {
    case 'AUTHENTICATION_ERROR':
      // 重定向到登录页面
      EventBus.getInstance().publish(Events.APP_LOGOUT_REQUIRED);
      break;

    case 'NETWORK_ERROR':
      // 显示网络错误提示
      EventBus.getInstance().publish('ui:notification', {
        type: 'error',
        message: '网络连接失败，请检查网络设置',
        duration: 5000,
      });
      break;

    case 'PERMISSION_ERROR':
      // 显示权限错误提示
      EventBus.getInstance().publish('ui:notification', {
        type: 'warning',
        message: error.message,
        duration: 3000,
      });
      break;

    default:
      // 显示通用错误提示
      EventBus.getInstance().publish('ui:notification', {
        type: 'error',
        message: '操作失败，请稍后重试',
        duration: 3000,
      });
  }
}
```

### 4.3 全局错误边界

```typescript
// src/renderer/components/ErrorBoundary/GlobalErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AppError } from '@shared/errors/AppErrors';
import { logger } from '@shared/utils/logger';
import { EventBus } from '@shared/events/EventBus';
import { ErrorFallback } from './ErrorFallback';

interface Props {
  children: ReactNode;
  fallback?: React.ComponentType<{ error: Error; resetError: () => void }>;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorId: string | null;
}

export class GlobalErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorId: null,
    };
  }

  static getDerivedStateFromError(error: Error): State {
    const errorId = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
      hasError: true,
      error,
      errorId,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const appError = error instanceof AppError ? error : new AppError(
      error.message,
      {
        componentStack: errorInfo.componentStack,
        errorBoundary: this.constructor.name,
      }
    );

    // 记录错误
    logger.error('React Error Boundary 捕获到错误:', {
      error: appError.toJSON(),
      errorInfo,
      errorId: this.state.errorId,
    });

    // 发送错误报告
    this.sendErrorReport(appError, errorInfo);

    // 发布错误事件
    EventBus.getInstance().publish('app:error', appError);
  }

  private async sendErrorReport(error: AppError, errorInfo: ErrorInfo): Promise<void> {
    try {
      // 发送错误报告到远程服务
      await fetch('/api/error-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          errorId: this.state.errorId,
          error: error.toJSON(),
          errorInfo,
          userAgent: navigator.userAgent,
          timestamp: new Date().toISOString(),
          url: window.location.href,
        }),
      });
    } catch (reportError) {
      logger.error('发送错误报告失败:', reportError);
    }
  }

  private resetError = (): void => {
    this.setState({
      hasError: false,
      error: null,
      errorId: null,
    });
  };

  render() {
    if (this.state.hasError && this.state.error) {
      const FallbackComponent = this.props.fallback || ErrorFallback;
      return (
        <FallbackComponent
          error={this.state.error}
          resetError={this.resetError}
        />
      );
    }

    return this.props.children;
  }
}

// 错误回退组件
// src/renderer/components/ErrorBoundary/ErrorFallback.tsx
interface ErrorFallbackProps {
  error: Error;
  resetError: () => void;
}

export const ErrorFallback: React.FC<ErrorFallbackProps> = ({
  error,
  resetError
}) => {
  const [showDetails, setShowDetails] = useState(false);

  const handleReload = () => {
    window.location.reload();
  };

  const handleReset = () => {
    resetError();
  };

  return (
    <ErrorContainer>
      <ErrorIcon>⚠️</ErrorIcon>
      <ErrorTitle>应用出现了问题</ErrorTitle>
      <ErrorMessage>
        很抱歉，应用遇到了意外错误。您可以尝试以下操作：
      </ErrorMessage>

      <ActionButtons>
        <PrimaryButton onClick={handleReset}>
          重试
        </PrimaryButton>
        <SecondaryButton onClick={handleReload}>
          刷新应用
        </SecondaryButton>
      </ActionButtons>

      <DetailsToggle onClick={() => setShowDetails(!showDetails)}>
        {showDetails ? '隐藏' : '显示'}错误详情
      </DetailsToggle>

      {showDetails && (
        <ErrorDetails>
          <DetailTitle>错误信息:</DetailTitle>
          <DetailContent>{error.message}</DetailContent>

          {error.stack && (
            <>
              <DetailTitle>错误堆栈:</DetailTitle>
              <DetailContent>
                <pre>{error.stack}</pre>
              </DetailContent>
            </>
          )}
        </ErrorDetails>
      )}
    </ErrorContainer>
  );
};
```

## 5. 性能优化设计

### 5.1 内存管理

```typescript
// src/shared/utils/MemoryManager.ts
export class MemoryManager {
  private static instance: MemoryManager;
  private cleanupTasks: Set<() => void> = new Set();
  private memoryCheckInterval: NodeJS.Timeout | null = null;

  private constructor() {
    this.startMemoryMonitoring();
  }

  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }

  // 注册清理任务
  registerCleanupTask(task: () => void): () => void {
    this.cleanupTasks.add(task);
    return () => this.cleanupTasks.delete(task);
  }

  // 执行内存清理
  performCleanup(): void {
    this.cleanupTasks.forEach(task => {
      try {
        task();
      } catch (error) {
        logger.error('内存清理任务执行失败:', error);
      }
    });

    // 强制垃圾回收（如果可用）
    if (global.gc) {
      global.gc();
    }
  }

  // 获取内存使用情况
  getMemoryUsage(): NodeJS.MemoryUsage {
    return process.memoryUsage();
  }

  // 检查内存使用是否过高
  isMemoryUsageHigh(): boolean {
    const usage = this.getMemoryUsage();
    const heapUsedMB = usage.heapUsed / 1024 / 1024;
    return heapUsedMB > 200; // 200MB 阈值
  }

  // 开始内存监控
  private startMemoryMonitoring(): void {
    this.memoryCheckInterval = setInterval(() => {
      if (this.isMemoryUsageHigh()) {
        logger.warn('内存使用过高，执行清理操作');
        this.performCleanup();
      }
    }, 30000); // 每30秒检查一次
  }

  // 停止内存监控
  stopMemoryMonitoring(): void {
    if (this.memoryCheckInterval) {
      clearInterval(this.memoryCheckInterval);
      this.memoryCheckInterval = null;
    }
  }

  // 销毁管理器
  destroy(): void {
    this.stopMemoryMonitoring();
    this.performCleanup();
    this.cleanupTasks.clear();
  }
}

// React Hook 用于自动内存管理
export const useMemoryCleanup = (cleanupFn: () => void) => {
  useEffect(() => {
    const memoryManager = MemoryManager.getInstance();
    const unregister = memoryManager.registerCleanupTask(cleanupFn);

    return unregister;
  }, [cleanupFn]);
};
```

### 5.2 缓存管理

```typescript
// src/shared/utils/CacheManager.ts
interface CacheItem<T> {
  data: T;
  timestamp: number;
  ttl: number;
  accessCount: number;
  lastAccessed: number;
}

export class CacheManager<T = any> {
  private cache = new Map<string, CacheItem<T>>();
  private maxSize: number;
  private defaultTTL: number;
  private cleanupInterval: NodeJS.Timeout;

  constructor(maxSize: number = 100, defaultTTL: number = 300000) { // 5分钟默认TTL
    this.maxSize = maxSize;
    this.defaultTTL = defaultTTL;

    // 定期清理过期缓存
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, 60000); // 每分钟清理一次
  }

  // 设置缓存
  set(key: string, data: T, ttl: number = this.defaultTTL): void {
    // 如果缓存已满，删除最少使用的项
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.evictLeastUsed();
    }

    const now = Date.now();
    this.cache.set(key, {
      data,
      timestamp: now,
      ttl,
      accessCount: 0,
      lastAccessed: now,
    });
  }

  // 获取缓存
  get(key: string): T | null {
    const item = this.cache.get(key);
    if (!item) return null;

    const now = Date.now();

    // 检查是否过期
    if (now - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }

    // 更新访问统计
    item.accessCount++;
    item.lastAccessed = now;

    return item.data;
  }

  // 检查缓存是否存在且未过期
  has(key: string): boolean {
    return this.get(key) !== null;
  }

  // 删除缓存
  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  // 清空所有缓存
  clear(): void {
    this.cache.clear();
  }

  // 获取缓存统计信息
  getStats() {
    const now = Date.now();
    let validCount = 0;
    let expiredCount = 0;
    let totalAccessCount = 0;

    this.cache.forEach(item => {
      if (now - item.timestamp <= item.ttl) {
        validCount++;
      } else {
        expiredCount++;
      }
      totalAccessCount += item.accessCount;
    });

    return {
      totalItems: this.cache.size,
      validItems: validCount,
      expiredItems: expiredCount,
      totalAccesses: totalAccessCount,
      hitRate: totalAccessCount > 0 ? validCount / totalAccessCount : 0,
    };
  }

  // 清理过期缓存
  private cleanup(): void {
    const now = Date.now();
    const keysToDelete: string[] = [];

    this.cache.forEach((item, key) => {
      if (now - item.timestamp > item.ttl) {
        keysToDelete.push(key);
      }
    });

    keysToDelete.forEach(key => this.cache.delete(key));

    if (keysToDelete.length > 0) {
      logger.debug(`清理了 ${keysToDelete.length} 个过期缓存项`);
    }
  }

  // 驱逐最少使用的缓存项
  private evictLeastUsed(): void {
    let leastUsedKey: string | null = null;
    let leastAccessCount = Infinity;
    let oldestAccess = Infinity;

    this.cache.forEach((item, key) => {
      if (item.accessCount < leastAccessCount ||
          (item.accessCount === leastAccessCount && item.lastAccessed < oldestAccess)) {
        leastUsedKey = key;
        leastAccessCount = item.accessCount;
        oldestAccess = item.lastAccessed;
      }
    });

    if (leastUsedKey) {
      this.cache.delete(leastUsedKey);
      logger.debug(`驱逐最少使用的缓存项: ${leastUsedKey}`);
    }
  }

  // 销毁缓存管理器
  destroy(): void {
    clearInterval(this.cleanupInterval);
    this.clear();
  }
}

// 全局缓存实例
export const globalCache = new CacheManager();

// React Hook 用于组件级缓存
export const useCache = <T>(key: string, fetcher: () => Promise<T>, ttl?: number) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    // 先尝试从缓存获取
    const cached = globalCache.get(key);
    if (cached) {
      setData(cached);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const result = await fetcher();
      globalCache.set(key, result, ttl);
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [key, fetcher, ttl]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const refetch = useCallback(() => {
    globalCache.delete(key);
    fetchData();
  }, [key, fetchData]);

  return { data, loading, error, refetch };
};
```

这个代码设计文档涵盖了AI面试助手桌面端的核心设计模式、架构模式、数据流设计、错误处理和性能优化等关键方面，为项目的技术实现提供了详细的指导。
